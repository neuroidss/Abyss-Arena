<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Abyss Arena</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: 'system-ui', sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas/nipplejs */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #messages {
            background: rgba(0,0,0,0.5);
            padding: 5px;
            max-height: 20vh;
            overflow-y: auto;
            pointer-events: all; /* Allow interaction with messages */
            margin-bottom: auto; /* Pushes controls down */
             color: #eee;
             font-size: 14px;
             border-bottom: 1px solid #444;
        }
        #messages div { margin-bottom: 3px; }
        #controls-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* Align items to the bottom */
            padding: 10px;
            pointer-events: none; /* Reset for children */
             height: 150px; /* Ensure space for joysticks */
        }
         #joystick-left, #joystick-right {
            position: relative; /* Needed for nipplejs */
            width: 100px;
            height: 100px;
            background: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            pointer-events: all;
        }
        #action-buttons {
             display: flex;
             flex-direction: column;
             align-items: center;
             pointer-events: all;
        }
        .action-button {
            background: rgba(80, 80, 80, 0.7);
            color: white;
            border: 1px solid #aaa;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            text-align: center;
        }
         .action-button:active {
             background: rgba(120, 120, 120, 0.8);
         }

        #llm-controls {
            position: fixed;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: all;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }
         #llm-controls label, #llm-controls select, #llm-controls button, #llm-controls input {
             display: block;
             margin-bottom: 3px;
         }
         #llm-chat {
             margin-top: 10px;
             display: flex;
             gap: 5px;
         }
         #llm-chat input { flex-grow: 1; }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 10001; /* Above jam link */
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Loading Assets...</div>
    <div id="messages"></div>
    <div id="ui-container">
        <!-- Messages div is dynamically positioned by flexbox -->
        <div></div> <!-- Spacer -->
        <div id="controls-area">
             <div id="joystick-left"></div>
             <div id="action-buttons">
                 <button id="attack-melee-button" class="action-button">Melee</button>
                 <button id="attack-range-button" class="action-button">Range</button>
                 <button id="interact-button" class="action-button">Pick</button>
             </div>
             <div id="joystick-right"></div>
        </div>
    </div>
    <div id="llm-controls">
        <label for="llm-engine-select">LLM Engine:</label>
        <select id="llm-engine-select">
            <option value="none">None</option>
            <option value="webllm">WebLLM (WebGPU)</option>
            <option value="llmjs">llm.js (CPU)</option>
            <!-- <option value="openai">OpenAI API</option> -->
            <!-- <option value="gemini">Gemini API</option> -->
            <!-- <option value="claude">Claude API</option> -->
            <!-- <option value="ollama">Ollama API</option> -->
        </select>
         <div id="webllm-options" style="display: none;">
             <label for="webllm-model-select">WebLLM Model:</label>
             <select id="webllm-model-select">
                 <option value="Qwen2.5-Coder-3B-Instruct-q4f32_1-MLC">Qwen2.5-Coder-3B</option>
                 <option value="Qwen2.5-Coder-7B-Instruct-q4f32_1-MLC" selected>Qwen2.5-Coder-7B</option>
                 <option value="DeepSeek-R1-Distill-Qwen-7B-q4f32_1-MLC">DeepSeek-R1-Distill-Qwen-7B</option>
             </select>
         </div>
         <div id="llmjs-options" style="display: none;">
             <label for="llmjs-model-select">llm.js Model:</label>
             <select id="llmjs-model-select">
                 <option value="https://huggingface.co/unsloth/Qwen2.5-Coder-3B-Instruct-128K-GGUF/resolve/main/Qwen2.5-Coder-3B-Instruct-Q4_K_M.gguf">Qwen2.5-Coder-3B</option>
                 <option value="https://huggingface.co/unsloth/Qwen2.5-Coder-7B-Instruct-128K-GGUF/resolve/main/Qwen2.5-Coder-7B-Instruct-Q4_K_M.gguf" selected>Qwen2.5-Coder-7B</option>
                 <option value="https://huggingface.co/unsloth/DeepSeek-R1-Distill-Qwen-7B-GGUF/resolve/main/DeepSeek-R1-Distill-Qwen-7B-Q4_K_M.gguf">DeepSeek-R1-Distill-Qwen-7B</option>
             </select>
         </div>
         <button id="load-llm-button">Load/Switch LLM</button>
         <label for="llm-temperature">Temperature:</label>
         <input type="range" id="llm-temperature" min="0" max="1.5" step="0.1" value="0.7">
         <span id="temperature-value">0.7</span>

         <div id="llm-status">Status: Not Loaded</div>
         <div id="llm-chat" style="display: none;"> <!-- Hidden until LLM loaded -->
            <input type="text" id="chat-input" placeholder="Chat with Abyss...">
            <button id="send-chat-button">Send</button>
         </div>
    </div>

    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;"> Vibe Jam 2025</a>

    <script type="module">
        // Imports
        import * as THREE from 'https://esm.run/three@0.160.0';
        import nipplejs from 'https://esm.run/nipplejs@0.10.1';
        import RAPIER from 'https://esm.run/@dimforge/rapier3d-compat@0.12.0'; // Use compat version
        import * as webllm from "https://esm.run/@mlc-ai/web-llm"; // Lazy load later?
        // LLM.js will be imported conditionally if needed

        console.log("Starting Abyss Arena...");

        // --- Global State ---
        let scene, camera, renderer, clock;
        let physicsWorld, eventQueue;
        let player = null; // Will hold player entity data
        const entities = new Map(); // Map<entityId, entityData>
        const artifacts = new Map(); // Map<artifactId, artifactData>
        let entityIdCounter = 0;
        let artifactIdCounter = 0;
        const ARENA_RADIUS = 50;
        const ARENA_HEIGHT = 10;
        const MAX_ARTIFACT_LIFETIME = 5 * 60 * 1000; // 5 minutes in milliseconds

        // LLM State
        let llmEngine = null;
        let llmType = 'none'; // 'none', 'webllm', 'llmjs', 'openai', etc.
        let llmModelId = '';
        let llmLoading = false;
        let llmReady = false;
        let chatHistory = [];
        const MAX_CHAT_HISTORY = 20; // Limit history size
        let availableLLMTools = {}; // { toolName: { description: string, function: Function, parameters: object } }
        let llmJsInstance = null; // For llm.js

        // Input State
        const inputState = {
            moveForward: 0, moveBackward: 0, moveLeft: 0, moveRight: 0,
            rotateLeft: 0, rotateRight: 0, rotateUp: 0, rotateDown: 0,
            actionMelee: false, actionRange: false, actionInteract: false,
            touchMove: { x: 0, y: 0 }, touchLook: { x: 0, y: 0 },
            gamepadConnected: false
        };
        let moveJoystick = null;
        let lookJoystick = null;

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const loadingOverlay = document.getElementById('loading-overlay');
        const llmEngineSelect = document.getElementById('llm-engine-select');
        const webllmOptionsDiv = document.getElementById('webllm-options');
        const llmjsOptionsDiv = document.getElementById('llmjs-options');
        const webllmModelSelect = document.getElementById('webllm-model-select');
        const llmjsModelSelect = document.getElementById('llmjs-model-select');
        const loadLlmButton = document.getElementById('load-llm-button');
        const llmStatusDiv = document.getElementById('llm-status');
        const llmChatDiv = document.getElementById('llm-chat');
        const chatInput = document.getElementById('chat-input');
        const sendChatButton = document.getElementById('send-chat-button');
        const llmTemperatureSlider = document.getElementById('llm-temperature');
        const temperatureValueSpan = document.getElementById('temperature-value');
        const attackMeleeButton = document.getElementById('attack-melee-button');
        const attackRangeButton = document.getElementById('attack-range-button');
        const interactButton = document.getElementById('interact-button');


        // --- Helper Functions ---
        function logMessage(text, type = 'info') {
            console.log(`[${type.toUpperCase()}] ${text}`);
            const div = document.createElement('div');
            div.textContent = text;
            if (type === 'error') div.style.color = 'red';
            if (type === 'llm') div.style.color = 'cyan';
            if (type === 'warning') div.style.color = 'orange';
            messagesDiv.appendChild(div);
            messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll
        }

        function generateUUID() { // Simple UUID for IDs
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Simple sound generation
        let audioCtx;
        function playSound(type = 'click', volume = 0.1, duration = 0.05) {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API not supported.");
                    return;
                }
            }
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            switch(type) {
                case 'pickup': oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); break; // A5
                case 'hit_melee': oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); break; // A3
                case 'hit_range': oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); break; // A4
                case 'destroy': oscillator.frequency.setValueAtTime(110, audioCtx.currentTime); break; // A2
                case 'error': oscillator.frequency.setValueAtTime(164, audioCtx.currentTime); oscillator.type = 'sawtooth'; break; // E3
                case 'tool_create': oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime); duration = 0.3; break;
                default: oscillator.frequency.setValueAtTime(660, audioCtx.currentTime); break; // E5 (click)
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // --- Entity & Artifact Management ---
        class Entity {
            constructor(id, position = { x: 0, y: 1, z: 0 }, isPlayer = false) {
                this.id = id;
                this.isPlayer = isPlayer;
                this.soul = isPlayer ? 'player_soul' : `npc_soul_${id}`; // Simplified soul representation
                this.mesh = new THREE.Group(); // Group to hold body + artifacts
                this.bodyMesh = new THREE.Mesh( // Simple representation
                    new THREE.CapsuleGeometry(0.4, 1.0),
                    new THREE.MeshStandardMaterial({ color: isPlayer ? 0x00ff00 : 0xff0000 })
                );
                this.bodyMesh.position.y = 0.9; // Adjust capsule base
                this.mesh.add(this.bodyMesh);
                this.mesh.position.set(position.x, position.y, position.z);
                scene.add(this.mesh);

                // Physics Body
                const rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(position.x, position.y, position.z)
                    .setLinearDamping(0.5) // Some damping
                    .setAngularDamping(1.0); // Prevent spinning easily
                this.rigidBody = physicsWorld.createRigidBody(rigidBodyDesc);
                const colliderDesc = RAPIER.ColliderDesc.capsule(0.5, 0.4) // height/2, radius
                    .setRestitution(0.1)
                    .setFriction(0.5)
                    .setDensity(1.0);
                this.collider = physicsWorld.createCollider(colliderDesc, this.rigidBody);
                this.collider.userData = { entityId: this.id, type: 'entity' }; // Link collider to entity

                this.artifacts = new Map(); // Map<abilityType, artifactData>
                this.hp = 100; // Base HP, maybe tied to core artifact later
                this.lastMoveTime = Date.now();
                this.lastSeeTime = Date.now();
                this.lastAttackTime = 0;
                this.target = null; // For AI / Ranged attacks

                entities.set(this.id, this);
                logMessage(`Created ${isPlayer ? 'Player' : 'Creature'} ${this.id}`, 'game');
            }

            addArtifact(artifact) {
                if (!artifact || !artifact.abilityType) return false;
                logMessage(`${this.id} trying to assemble ${artifact.id} (${artifact.abilityType})`, 'game');

                // Simple upgrade: If already have this type, destroy the weaker one (or just refresh time)
                if (this.artifacts.has(artifact.abilityType)) {
                     const existingArtifact = this.artifacts.get(artifact.abilityType);
                     logMessage(`Upgrading ${artifact.abilityType}. Refreshing timer.`, 'game');
                     existingArtifact.creationTime = Date.now(); // Refresh timer
                     // TODO: Implement level upgrades later
                     destroyArtifact(artifact.id); // Destroy the new one after upgrading the old one
                     playSound('pickup');
                     return true;
                }

                this.artifacts.set(artifact.abilityType, artifact);
                artifact.attachedTo = this.id;
                // Visually attach artifact (simple offset)
                const artifactMesh = artifacts.get(artifact.id)?.mesh;
                if (artifactMesh) {
                    this.mesh.add(artifactMesh);
                    // Position artifacts simply around the body
                    const angle = (this.artifacts.size * Math.PI / 4); // Example positioning
                    artifactMesh.position.set(Math.sin(angle) * 0.6, 1.0, Math.cos(angle) * 0.6);
                }
                logMessage(`${this.id} assembled ${artifact.id} (${artifact.abilityType})`, 'game');
                playSound('pickup');

                // Update player capabilities display or flags if needed
                if (this.isPlayer) updatePlayerUI();

                return true;
            }

            removeArtifact(abilityType) {
                if (this.artifacts.has(abilityType)) {
                    const artifact = this.artifacts.get(abilityType);
                    logMessage(`${this.id} lost artifact ${artifact.id} (${abilityType})`, 'game');
                    this.artifacts.delete(abilityType);
                    // Detach mesh (it will be removed by destroyArtifact)
                    // If it's a vital artifact (like core body?), handle entity death
                    if (this.isPlayer) updatePlayerUI();
                    // Return the artifact ID so it can be fully destroyed
                    return artifact.id;
                }
                return null;
            }

            hasAbility(abilityType) {
                return this.artifacts.has(abilityType);
            }

            getAbility(abilityType) {
                return this.artifacts.get(abilityType);
            }

            update(deltaTime) {
                // Sync mesh position with physics body
                const bodyPosition = this.rigidBody.translation();
                this.mesh.position.copy(bodyPosition);
                // Sync rotation (important for camera later) - handle quaternion conversion
                const bodyRotation = this.rigidBody.rotation();
                this.mesh.quaternion.set(bodyRotation.x, bodyRotation.y, bodyRotation.z, bodyRotation.w);

                // Basic AI for non-player entities
                if (!this.isPlayer) {
                    this.simpleAI(deltaTime);
                }

                // Check artifact expiration (Abyss reclaiming)
                const now = Date.now();
                const expiredTypes = [];
                for (const [type, artifact] of this.artifacts.entries()) {
                    if (now > artifact.creationTime + MAX_ARTIFACT_LIFETIME) {
                        let disassemble = false;
                        // Check usage - very basic check
                        if (type === 'move' && now > this.lastMoveTime + 30000) disassemble = true; // No move in 30s
                        if (type === 'see' && now > this.lastSeeTime + 60000) disassemble = true; // No look/scan in 60s

                        if (disassemble && Math.random() < 0.3) { // Chance to disassemble
                             logMessage(`Abyss reclaims expired ${type} artifact ${artifact.id} from ${this.id}`, 'warning');
                             expiredTypes.push(type);
                             playSound('destroy');
                        } else {
                            // Reset timer slightly if not disassembled (grace period)
                            artifact.creationTime = now - MAX_ARTIFACT_LIFETIME + 10000;
                        }
                    }
                }
                expiredTypes.forEach(type => {
                    const artifactId = this.removeArtifact(type);
                    if (artifactId) destroyArtifact(artifactId);
                });

                 // Basic HP Regen if not recently hit? (Placeholder)
                 // this.hp = Math.min(100, this.hp + deltaTime * 1);
            }

            simpleAI(deltaTime) {
                // Rudimentary AI: Move randomly or towards player if close
                const distanceToPlayer = player ? this.mesh.position.distanceTo(player.mesh.position) : Infinity;
                const aggroRadius = 15 + (ARENA_RADIUS - this.mesh.position.length()) * 0.2; // More aggro closer to center

                if (this.hasAbility('move')) {
                    let moveTarget = null;
                    if (distanceToPlayer < aggroRadius) {
                        moveTarget = player.mesh.position;
                        this.target = player; // Target player for attacks
                    } else {
                        this.target = null;
                        // Random wander (occasional change)
                        if (Math.random() < 0.01) {
                            this.wanderTarget = new THREE.Vector3(
                                (Math.random() - 0.5) * ARENA_RADIUS * 1.5,
                                1,
                                (Math.random() - 0.5) * ARENA_RADIUS * 1.5
                            );
                        }
                        if (this.wanderTarget) {
                           moveTarget = this.wanderTarget;
                           if(this.mesh.position.distanceTo(this.wanderTarget) < 2) this.wanderTarget = null; // Reached wander point
                        }
                    }

                    if (moveTarget) {
                        const moveDir = new THREE.Vector3().subVectors(moveTarget, this.mesh.position).normalize();
                        moveDir.y = 0; // Don't move vertically
                        const force = moveDir.multiplyScalar(20); // AI move force
                        this.rigidBody.applyImpulse({ x: force.x * deltaTime, y: 0, z: force.z * deltaTime }, true);
                        this.lastMoveTime = Date.now();

                        // Rotate towards target
                        const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                            new THREE.Vector3(0, 0, 1), // Default forward
                             moveDir
                         );
                         const currentRotation = this.rigidBody.rotation();
                         const currentQuaternion = new THREE.Quaternion(currentRotation.x, currentRotation.y, currentRotation.z, currentRotation.w);
                         currentQuaternion.slerp(targetQuaternion, 0.1); // Smooth rotation
                         this.rigidBody.setRotation(currentQuaternion, true);
                    }
                }

                 // Basic Attack AI
                 if (this.target && Date.now() > this.lastAttackTime + 2000) { // Cooldown
                     const attackDistance = this.mesh.position.distanceTo(this.target.mesh.position);
                     if (this.hasAbility('attack_melee') && attackDistance < 2.0) {
                         this.performAttack('attack_melee', this.target);
                     } else if (this.hasAbility('attack_range') && attackDistance < 20) {
                         this.performAttack('attack_range', this.target);
                     }
                 }

                 // Simulate 'seeing'
                 if (this.hasAbility('see') && Math.random() < 0.1) {
                     this.lastSeeTime = Date.now();
                     // Basic scan - just updates aggro check above
                 }
            }

            performAttack(type, targetEntity = null) {
                if (!this.hasAbility(type) || Date.now() < this.lastAttackTime + (type === 'attack_melee' ? 500 : 1000)) {
                    return; // Check cooldown based on type
                }
                this.lastAttackTime = Date.now();
                const artifact = this.getAbility(type);
                const damage = type === 'attack_melee' ? 20 : 10; // Melee stronger
                const range = type === 'attack_melee' ? 2.0 : 30.0;

                logMessage(`${this.id} uses ${type} (Damage: ${damage}, Range: ${range})`, 'combat');

                if (type === 'attack_melee') {
                    playSound('hit_melee');
                    // Check entities in range (simple sphere check for now)
                    const attackPos = this.mesh.position.clone();
                    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
                    attackPos.add(forward.multiplyScalar(1.0)); // Check slightly in front

                    entities.forEach(entity => {
                        if (entity.id !== this.id && entity.mesh.position.distanceTo(attackPos) < range) {
                             logMessage(`${this.id} hits ${entity.id} with melee!`, 'combat');
                             entity.takeDamage(damage, this.id);
                        }
                    });
                } else { // attack_range
                    playSound('hit_range');
                    // Create a projectile
                    const projectileGeo = new THREE.SphereGeometry(0.1, 8, 8);
                    const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const projectileMesh = new THREE.Mesh(projectileGeo, projectileMat);

                    const startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)); // Start near 'head'
                    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
                    projectileMesh.position.copy(startPos).add(forward.multiplyScalar(0.5)); // Start slightly ahead

                    const projectileBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                        .setTranslation(projectileMesh.position.x, projectileMesh.position.y, projectileMesh.position.z)
                        .setGravityScale(0.2) // Less affected by gravity
                        .setCcdEnabled(true); // Continuous Collision Detection for fast objects
                    const projectileBody = physicsWorld.createRigidBody(projectileBodyDesc);

                    const projectileColliderDesc = RAPIER.ColliderDesc.ball(0.1)
                        .setSensor(true) // Sensor detects collision but doesn't cause physical reaction
                        .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                    const projectileCollider = physicsWorld.createCollider(projectileColliderDesc, projectileBody);
                    projectileCollider.userData = { type: 'projectile', damage: damage, ownerId: this.id, mesh: projectileMesh };

                    // Apply initial impulse
                    const speed = 30.0;
                    projectileBody.applyImpulse(forward.multiplyScalar(speed), true);

                    scene.add(projectileMesh);

                    // Self-destruct after time
                    setTimeout(() => {
                        scene.remove(projectileMesh);
                        if (physicsWorld.getRigidBody(projectileBody.handle)) { // Check if still exists
                            physicsWorld.removeRigidBody(projectileBody);
                        }
                    }, 3000); // Projectile lasts 3 seconds
                }
            }

            takeDamage(amount, attackerId) {
                 // Damage first tries to break a random artifact, then HP
                 const artifactKeys = Array.from(this.artifacts.keys());
                 if (artifactKeys.length > 0) {
                     const randomType = artifactKeys[Math.floor(Math.random() * artifactKeys.length)];
                     const artifactId = this.removeArtifact(randomType);
                     if (artifactId) {
                         logMessage(`${this.id}'s ${randomType} artifact was destroyed by ${attackerId}!`, 'combat');
                         destroyArtifact(artifactId);
                         playSound('destroy');
                     }
                 } else {
                     this.hp -= amount;
                     logMessage(`${this.id} took ${amount} direct damage from ${attackerId}. HP: ${this.hp}`, 'combat');
                     if (this.hp <= 0) {
                         this.die();
                     }
                 }
            }

            die() {
                logMessage(`${this.id} has been defeated. Soul absorbed by the Abyss.`, 'game');
                playSound('destroy');
                // Remove all remaining artifacts
                const artifactTypes = Array.from(this.artifacts.keys());
                artifactTypes.forEach(type => {
                    const artifactId = this.removeArtifact(type);
                    if (artifactId) destroyArtifact(artifactId);
                });

                // Remove entity from game
                scene.remove(this.mesh);
                 if (physicsWorld.getRigidBody(this.rigidBody.handle)) {
                    physicsWorld.removeRigidBody(this.rigidBody);
                }
                entities.delete(this.id);

                // TODO: Handle player death (respawn? game over?)
                if (this.isPlayer) {
                    logMessage("YOU DIED. The Abyss consumes your soul... for now.", 'error');
                    // Simple reload for now in jam context
                    setTimeout(() => window.location.reload(), 3000);
                } else {
                    // Non-LLM: Maybe drop an artifact?
                     if (Math.random() < 0.3) { // Chance to drop something
                         createArtifact(null, this.mesh.position); // Create a random one nearby
                     }
                    // LLM Mode: Soul is now available for the Abyss LLM to potentially reuse
                    if (llmReady) {
                        logMessage(`Soul ${this.soul} is now free in the Abyss.`, 'llm');
                        // Future: LLM could decide to inhabit a new artifact with this soul.
                    }
                }
            }

             interact() {
                 if (!this.isPlayer) return; // Only player interacts actively

                 const interactionRadius = 2.0;
                 let closestArtifact = null;
                 let minDist = interactionRadius;

                 const playerPos = this.mesh.position;

                 artifacts.forEach(artifact => {
                     if (!artifact.attachedTo && artifact.mesh) { // Only interact with unattached artifacts
                         const dist = playerPos.distanceTo(artifact.mesh.position);
                         if (dist < minDist) {
                             minDist = dist;
                             closestArtifact = artifact;
                         }
                     }
                 });

                 if (closestArtifact) {
                     logMessage(`Player attempts to pick up ${closestArtifact.id} (${closestArtifact.abilityType})`, 'game');
                     if (this.addArtifact(closestArtifact)) {
                         // Successfully added (or upgraded)
                         // Artifact mesh is now attached in addArtifact
                     } else {
                         logMessage(`Could not assemble ${closestArtifact.id}.`, 'warning');
                     }
                 } else {
                     logMessage("Nothing nearby to interact with.", 'info');
                 }
             }
        }

        class Artifact {
            constructor(id, abilityType, position = { x: 0, y: 0.5, z: 0 }, level = 1) {
                this.id = id;
                this.abilityType = abilityType || getRandomAbilityType(); // e.g., 'move', 'see', 'attack_melee', 'attack_range', 'tool_creation_tool'
                this.level = level;
                this.creationTime = Date.now();
                this.attachedTo = null; // Entity ID if attached

                // Visual representation
                let geometry, material;
                switch (this.abilityType) {
                    case 'move':
                        geometry = new THREE.ConeGeometry(0.2, 0.4, 4);
                        material = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue
                        break;
                    case 'see':
                        geometry = new THREE.SphereGeometry(0.2, 8, 8);
                        material = new THREE.MeshStandardMaterial({ color: 0xffff00 }); // Yellow
                        break;
                    case 'attack_melee':
                        geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                        material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
                        break;
                    case 'attack_range':
                        geometry = new THREE.TorusGeometry(0.15, 0.05, 8, 16);
                        material = new THREE.MeshStandardMaterial({ color: 0xffa500 }); // Orange
                        break;
                     case 'tool_creation_tool':
                         geometry = new THREE.IcosahedronGeometry(0.25);
                         material = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa }); // Cyan, glowing
                         break;
                    default:
                        geometry = new THREE.DodecahedronGeometry(0.2);
                        material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa }); // Grey
                }
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(position.x, position.y, position.z);
                this.mesh.userData = { artifactId: this.id, type: 'artifact' };
                scene.add(this.mesh);

                artifacts.set(this.id, this);
                logMessage(`Created Artifact ${this.id} (${this.abilityType}) at ${position.x.toFixed(1)}, ${position.z.toFixed(1)}`, 'game');
            }
        }

        function createArtifact(abilityType = null, position = null) {
            const id = `artifact_${artifactIdCounter++}`;
            if (!position) {
                // Random position within arena, avoiding center slightly initially
                const radius = Math.random() * (ARENA_RADIUS - 5) + 5;
                const angle = Math.random() * Math.PI * 2;
                position = { x: Math.cos(angle) * radius, y: 0.5, z: Math.sin(angle) * radius };
            }
            return new Artifact(id, abilityType, position);
        }

        function destroyArtifact(artifactId) {
            const artifact = artifacts.get(artifactId);
            if (artifact) {
                if (artifact.mesh) {
                    // If attached, the parent group (entity mesh) should already have removed it
                    if (!artifact.attachedTo) {
                         scene.remove(artifact.mesh);
                    } else {
                        // Ensure it's removed from the parent mesh if somehow still attached
                        const owner = entities.get(artifact.attachedTo);
                        owner?.mesh?.remove(artifact.mesh);
                    }
                }
                artifacts.delete(artifactId);
                logMessage(`Destroyed Artifact ${artifactId}`, 'game');
            }
        }

         function getRandomAbilityType(allowToolCreation = false) {
             const types = ['move', 'see', 'attack_melee', 'attack_range'];
             // Very low chance for tool creation artifact normally
             if (allowToolCreation && Math.random() < 0.01) {
                return 'tool_creation_tool';
             }
             return types[Math.floor(Math.random() * types.length)];
         }

        // --- Physics ---
        async function initPhysics() {
            logMessage("Initializing Physics Engine (Rapier)...", 'system');
            await RAPIER.init();
            const gravity = { x: 0.0, y: -9.81, z: 0.0 };
            physicsWorld = new RAPIER.World(gravity);
            eventQueue = new RAPIER.EventQueue(true); // Enable contact event reporting
            logMessage("Physics Engine Ready.", 'system');
        }

        function setupArena() {
            // Ground
            const groundSize = ARENA_RADIUS * 2.5; // Make ground larger than walls
            const groundHeight = 0.1;
            const groundGeo = new THREE.CylinderGeometry(ARENA_RADIUS, ARENA_RADIUS, groundHeight, 64);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.2, roughness: 0.8 });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.position.y = -groundHeight / 2;
            scene.add(groundMesh);

            const groundBodyDesc = RAPIER.RigidBodyDesc.fixed();
            const groundColliderDesc = RAPIER.ColliderDesc.cylinder(groundHeight / 2, ARENA_RADIUS);
            physicsWorld.createCollider(groundColliderDesc, physicsWorld.createRigidBody(groundBodyDesc).handle);

            // Arena Walls (Invisible)
            const wallHeight = ARENA_HEIGHT;
            const wallThickness = 1.0;
            const wallBodyDesc = RAPIER.RigidBodyDesc.fixed();
            const wallColliderDesc = RAPIER.ColliderDesc.cylinder(wallHeight / 2, ARENA_RADIUS + wallThickness / 2) // Outer cylinder
                 .setTranslation(0, wallHeight / 2, 0); // Position it correctly
            // This creates a solid cylinder, we want a hollow one. Rapier doesn't have direct hollow cylinder.
            // Workaround: Use multiple segments or just rely on the outer boundary.
            // For simplicity, we'll just use the solid cylinder boundary collider. It prevents escape.
            // A better way would be Heightfield or multiple Cuboid colliders forming a ring.
            // Let's stick to the simple cylinder boundary for the jam.
             const wallBody = physicsWorld.createRigidBody(wallBodyDesc);
             const wallCollider = RAPIER.ColliderDesc.cylinder(wallHeight / 2, ARENA_RADIUS)
                .setTranslation(0, wallHeight / 2, 0);
             // We actually want the *outside* to be solid, which is tricky.
             // Let's just make a thick visual wall instead for clarity and use the ground collider.
             // And add logic to push entities back if they exceed radius.

             // Alternative: Make a visual wall
             const wallGeo = new THREE.CylinderGeometry(ARENA_RADIUS, ARENA_RADIUS, wallHeight, 64, 1, true); // Open ended
             const wallMat = new THREE.MeshStandardMaterial({ color: 0x886666, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
             const wallMesh = new THREE.Mesh(wallGeo, wallMat);
             wallMesh.position.y = wallHeight / 2;
             scene.add(wallMesh);

             // Add a physics ceiling (invisible)
             const ceilingColliderDesc = RAPIER.ColliderDesc.cuboid(ARENA_RADIUS * 1.5, 0.1, ARENA_RADIUS * 1.5)
                .setTranslation(0, ARENA_HEIGHT + 0.1, 0);
            physicsWorld.createCollider(ceilingColliderDesc, wallBody.handle); // Attach to the fixed wall body

            logMessage(`Arena created with radius ${ARENA_RADIUS}.`, 'game');
        }

         function handleCollisions() {
             eventQueue.drainCollisionEvents((handle1, handle2, started) => {
                 if (!started) return; // Only handle collision start events

                 const collider1 = physicsWorld.getCollider(handle1);
                 const collider2 = physicsWorld.getCollider(handle2);

                 const userData1 = collider1.userData;
                 const userData2 = collider2.userData;

                 // Projectile collision
                 if (userData1?.type === 'projectile' || userData2?.type === 'projectile') {
                     const projectileData = userData1.type === 'projectile' ? userData1 : userData2;
                     const otherData = userData1.type === 'projectile' ? userData2 : userData1;
                     const projectileCollider = userData1.type === 'projectile' ? collider1 : collider2;
                     const projectileBody = projectileCollider.parent();


                     if (otherData?.type === 'entity' && otherData.entityId !== projectileData.ownerId) {
                         const targetEntity = entities.get(otherData.entityId);
                         if (targetEntity) {
                             logMessage(`Projectile from ${projectileData.ownerId} hit ${targetEntity.id}!`, 'combat');
                             targetEntity.takeDamage(projectileData.damage, projectileData.ownerId);
                         }
                     }
                     // Remove projectile on any impact (except maybe other projectiles)
                     if (otherData?.type !== 'projectile') {
                         if (projectileData.mesh) scene.remove(projectileData.mesh);
                         if (projectileBody && physicsWorld.getRigidBody(projectileBody.handle)) {
                             physicsWorld.removeRigidBody(projectileBody);
                         }
                     }
                 }
             });
         }

        // --- Controls ---
        function initControls() {
            logMessage("Initializing Controls...", 'system');
            // Keyboard
            window.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': case 'ArrowUp': inputState.moveForward = 1; break;
                    case 'KeyS': case 'ArrowDown': inputState.moveBackward = 1; break;
                    case 'KeyA': case 'ArrowLeft': inputState.moveLeft = 1; break;
                    case 'KeyD': case 'ArrowRight': inputState.moveRight = 1; break;
                    case 'KeyQ': inputState.rotateLeft = 1; break;
                    case 'KeyE': inputState.rotateRight = 1; break;
                    case 'KeyF': case 'Space': inputState.actionInteract = true; break; // Interact
                    case 'Digit1': case 'KeyJ': inputState.actionMelee = true; break; // Melee Attack
                    case 'Digit2': case 'KeyK': inputState.actionRange = true; break; // Range Attack
                }
            });
            window.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': case 'ArrowUp': inputState.moveForward = 0; break;
                    case 'KeyS': case 'ArrowDown': inputState.moveBackward = 0; break;
                    case 'KeyA': case 'ArrowLeft': inputState.moveLeft = 0; break;
                    case 'KeyD': case 'ArrowRight': inputState.moveRight = 0; break;
                    case 'KeyQ': inputState.rotateLeft = 0; break;
                    case 'KeyE': inputState.rotateRight = 0; break;
                    case 'KeyF': case 'Space': inputState.actionInteract = false; break;
                    case 'Digit1': case 'KeyJ': inputState.actionMelee = false; break;
                    case 'Digit2': case 'KeyK': inputState.actionRange = false; break;
                }
            });

            // Mouse Look (Basic - only horizontal for now)
            // window.addEventListener('mousemove', (e) => {
            //     if (document.pointerLockElement === renderer.domElement) {
            //         inputState.rotateLeft -= e.movementX * 0.002;
            //         inputState.rotateRight += e.movementX * 0.002;
            //         // inputState.rotateUp -= e.movementY * 0.002; // Add vertical look later if needed
            //         // inputState.rotateDown += e.movementY * 0.002;
            //     }
            // });
            // renderer.domElement.addEventListener('click', () => {
            //     renderer.domElement.requestPointerLock();
            // });

             // Touch Controls (NippleJS)
             try {
                 const joystickZoneLeft = document.getElementById('joystick-left');
                 const joystickZoneRight = document.getElementById('joystick-right');

                 if (joystickZoneLeft && joystickZoneRight) {
                     const joystickOptions = {
                         zone: joystickZoneLeft,
                         mode: 'static',
                         position: { left: '50%', top: '50%' },
                         color: 'white',
                         size: 80
                     };
                     moveJoystick = nipplejs.create(joystickOptions);

                     moveJoystick.on('move', (evt, data) => {
                         if (data.vector) {
                             inputState.touchMove.x = data.vector.x;
                             inputState.touchMove.y = data.vector.y;
                         }
                     });
                     moveJoystick.on('end', () => {
                         inputState.touchMove.x = 0;
                         inputState.touchMove.y = 0;
                     });

                     const lookJoystickOptions = {
                         zone: joystickZoneRight,
                         mode: 'static',
                         position: { left: '50%', top: '50%' },
                         color: 'white',
                         size: 80
                     };
                     lookJoystick = nipplejs.create(lookJoystickOptions);

                     lookJoystick.on('move', (evt, data) => {
                         if (data.vector) {
                             inputState.touchLook.x = data.vector.x;
                             inputState.touchLook.y = data.vector.y; // Use for vertical look later?
                         }
                     });
                     lookJoystick.on('end', () => {
                         inputState.touchLook.x = 0;
                         inputState.touchLook.y = 0;
                     });

                     logMessage("Touch controls initialized.", 'system');
                 } else {
                     logMessage("Joystick zones not found.", 'warning');
                 }

                 // Touch Buttons
                 attackMeleeButton.addEventListener('touchstart', (e) => { e.preventDefault(); inputState.actionMelee = true; playSound(); });
                 attackMeleeButton.addEventListener('touchend', (e) => { e.preventDefault(); inputState.actionMelee = false; });
                 attackRangeButton.addEventListener('touchstart', (e) => { e.preventDefault(); inputState.actionRange = true; playSound(); });
                 attackRangeButton.addEventListener('touchend', (e) => { e.preventDefault(); inputState.actionRange = false; });
                 interactButton.addEventListener('touchstart', (e) => { e.preventDefault(); inputState.actionInteract = true; playSound(); });
                 interactButton.addEventListener('touchend', (e) => { e.preventDefault(); inputState.actionInteract = false; });

             } catch (err) {
                 logMessage(`Failed to initialize NippleJS: ${err}`, 'error');
             }


            // Gamepad API
            window.addEventListener("gamepadconnected", (event) => {
                logMessage(`Gamepad connected: ${event.gamepad.id}`, 'system');
                inputState.gamepadConnected = true;
            });
            window.addEventListener("gamepaddisconnected", (event) => {
                logMessage(`Gamepad disconnected: ${event.gamepad.id}`, 'system');
                inputState.gamepadConnected = false;
            });

            logMessage("Controls Initialized.", 'system');
        }

        function processInput(deltaTime) {
            if (!player || !player.rigidBody) return;

            let moveImpulse = { x: 0, y: 0, z: 0 };
            let rotationImpulse = { x: 0, y: 0, z: 0 }; // Using torque for rotation
            const moveSpeed = 40.0;
            const rotateSpeed = 2.0;

            // --- Gamepad Input ---
            if (inputState.gamepadConnected) {
                const gamepads = navigator.getGamepads();
                for (const gp of gamepads) {
                    if (!gp) continue;

                    // Axes (Left Stick for Move, Right Stick for Look)
                    const leftStickX = gp.axes[0];
                    const leftStickY = gp.axes[1];
                    const rightStickX = gp.axes[2];
                    // const rightStickY = gp.axes[3]; // Vertical look

                    if (Math.abs(leftStickY) > 0.1) moveImpulse.z -= leftStickY;
                    if (Math.abs(leftStickX) > 0.1) moveImpulse.x += leftStickX;
                    if (Math.abs(rightStickX) > 0.1) rotationImpulse.y -= rightStickX * rotateSpeed;
                    // Add vertical look later if needed using rightStickY

                    // Buttons (Example mapping - check your gamepad layout)
                    if (gp.buttons[0]?.pressed) inputState.actionInteract = true; // A / Cross
                    if (gp.buttons[2]?.pressed) inputState.actionMelee = true; // X / Square
                    if (gp.buttons[3]?.pressed) inputState.actionRange = true; // Y / Triangle
                    // Reset button states if not pressed (handle release)
                    if (!gp.buttons[0]?.pressed) inputState.actionInteract = false;
                    if (!gp.buttons[2]?.pressed) inputState.actionMelee = false;
                    if (!gp.buttons[3]?.pressed) inputState.actionRange = false;

                    break; // Use first connected gamepad
                }
            }

            // --- Keyboard Input (Overrides Gamepad if pressed) ---
            if (inputState.moveForward) moveImpulse.z -= 1;
            if (inputState.moveBackward) moveImpulse.z += 1;
            if (inputState.moveLeft) moveImpulse.x -= 1;
            if (inputState.moveRight) moveImpulse.x += 1;
            if (inputState.rotateLeft) rotationImpulse.y += rotateSpeed;
            if (inputState.rotateRight) rotationImpulse.y -= rotateSpeed;

            // --- Touch Input (Overrides Keyboard/Gamepad if active) ---
            if (Math.abs(inputState.touchMove.y) > 0.1 || Math.abs(inputState.touchMove.x) > 0.1) {
                moveImpulse.z = -inputState.touchMove.y;
                moveImpulse.x = inputState.touchMove.x;
            }
             if (Math.abs(inputState.touchLook.x) > 0.1) {
                 rotationImpulse.y = -inputState.touchLook.x * rotateSpeed;
             }
             // inputState.actionMelee, actionRange, actionInteract are set directly by touch buttons

            // --- Apply Movement ---
            if (player.hasAbility('move')) {
                const moveVec = new THREE.Vector3(moveImpulse.x, 0, moveImpulse.z);
                moveVec.normalize().multiplyScalar(moveSpeed * deltaTime);

                // Apply impulse relative to player's current rotation
                const worldImpulse = moveVec.applyQuaternion(player.mesh.quaternion);
                player.rigidBody.applyImpulse(worldImpulse, true);
                if (moveVec.lengthSq() > 0) player.lastMoveTime = Date.now();
            } else if (moveImpulse.x !== 0 || moveImpulse.z !== 0) {
                logMessage("Cannot move without a 'move' artifact!", 'warning');
            }

            // --- Apply Rotation ---
             // Rotation only needs 'see' artifact? Or is it innate? Let's say innate for now.
             // if (player.hasAbility('see')) {
                player.rigidBody.applyTorqueImpulse({ x: 0, y: rotationImpulse.y * deltaTime, z: 0 }, true);
                if (rotationImpulse.y !== 0) player.lastSeeTime = Date.now(); // Consider rotation as 'seeing'
             // } else if (rotationImpulse.y !== 0) {
             //    logMessage("Cannot look around without a 'see' artifact!", 'warning');
             // }


            // --- Actions ---
            if (inputState.actionInteract) {
                player.interact();
                inputState.actionInteract = false; // Trigger once per press/touch
            }
            if (inputState.actionMelee) {
                player.performAttack('attack_melee');
                 // Cooldown is handled within performAttack
                 // inputState.actionMelee = false; // Don't reset here, allow holding button if desired
            }
            if (inputState.actionRange) {
                player.performAttack('attack_range');
                 // Cooldown is handled within performAttack
                 // inputState.actionRange = false;
            }
        }

        // --- LLM Integration ---
        function updateLLMControls() {
            const selectedEngine = llmEngineSelect.value;
            webllmOptionsDiv.style.display = selectedEngine === 'webllm' ? 'block' : 'none';
            llmjsOptionsDiv.style.display = selectedEngine === 'llmjs' ? 'block' : 'none';
            // Add similar lines for other API options if implemented

            llmStatusDiv.textContent = `Status: ${llmLoading ? 'Loading...' : (llmReady ? `Ready (${llmType} - ${llmModelId})` : 'Not Loaded')}`;
            llmChatDiv.style.display = llmReady ? 'flex' : 'none';
        }

        async function loadLLM() {
            const selectedEngine = llmEngineSelect.value;
            if (selectedEngine === 'none') {
                unloadLLM();
                return;
            }
            if (llmLoading) {
                logMessage("LLM is already loading.", 'warning');
                return;
            }

            unloadLLM(); // Unload previous engine if any
            llmLoading = true;
            llmType = selectedEngine;
            llmModelId = ''; // Reset model ID
            updateLLMControls();
            logMessage(`Loading LLM Engine: ${llmType}...`, 'llm');

            try {
                if (llmType === 'webllm') {
                    llmModelId = webllmModelSelect.value;
                    logMessage(`Loading WebLLM model: ${llmModelId}`, 'llm');
                    llmStatusDiv.textContent = 'Status: Initializing WebLLM Engine...';
                    const engine = await webllm.CreateMLCEngine(
                        llmModelId,
                        {
                            initProgressCallback: (report) => {
                                const progress = report.progress ? (report.progress * 100).toFixed(2) : 0;
                                llmStatusDiv.textContent = `Status: Loading ${llmModelId} - ${report.text} (${progress}%)`;
                                console.log(report);
                            }
                        }
                    );
                    llmEngine = engine; // Assign to global scope
                    llmReady = true;
                    logMessage("WebLLM Engine Ready.", 'llm');
                } else if (llmType === 'llmjs') {
                    llmModelId = llmjsModelSelect.options[llmjsModelSelect.selectedIndex].text; // Get display name
                    const modelUrl = llmjsModelSelect.value;
                    logMessage(`Loading llm.js model: ${llmModelId} from ${modelUrl}`, 'llm');
                    llmStatusDiv.textContent = `Status: Downloading ${llmModelId}...`;

                    // Dynamically import llm.js
                    const { LLM } = await import('./llm.js/llm.js');

                    llmJsInstance = new LLM(
                        'GGUF_CPU', // Type
                        modelUrl,   // Model URL
                        () => {     // On loaded
                            logMessage("llm.js Model Loaded.", 'llm');
                            llmReady = true;
                            llmLoading = false;
                            updateLLMControls();
                        },
                        (text) => { // Write result (we'll handle response differently)
                             console.log("LLM.js raw output:", text); // Log raw output if needed
                        },
                        () => {     // Run complete
                            logMessage("llm.js Run Complete.", 'llm');
                        },
                         (error) => { // On Error
                            logMessage(`llm.js Error: ${error}`, 'error');
                            unloadLLM(); // Reset state on error
                         }
                    );
                    llmStatusDiv.textContent = `Status: Loading ${llmModelId} into llm.js worker...`;
                    llmJsInstance.load_worker(); // Start loading
                     // Note: llm.js loading is asynchronous, on_loaded callback handles readiness.
                     // We set llmLoading = false inside the on_loaded callback.

                } else if (llmType === 'openai' || llmType === 'gemini' || llmType === 'claude' || llmType === 'ollama') {
                    logMessage(`API for ${llmType} not implemented yet.`, 'warning');
                     throw new Error("API not implemented");
                    // TODO: Implement API calls using fetch
                    // Need to handle API keys and endpoint URLs securely
                    // llmReady = true; // Placeholder
                } else {
                     throw new Error("Invalid LLM engine selected");
                }

            } catch (error) {
                logMessage(`Failed to load LLM: ${error}`, 'error');
                unloadLLM();
            } finally {
                // Only set loading false here if not handled by async callback (like llm.js)
                 if (llmType !== 'llmjs') {
                    llmLoading = false;
                 }
                updateLLMControls();
            }
        }

        function unloadLLM() {
            if (llmEngine && llmType === 'webllm') {
                llmEngine.unload(); // Release WebLLM resources
            }
            if (llmJsInstance && llmType === 'llmjs') {
                 // llm.js might not have an explicit unload, just stop using it
                 llmJsInstance = null;
            }
            llmEngine = null;
            llmReady = false;
            llmLoading = false;
            llmType = 'none';
            llmModelId = '';
            chatHistory = [];
            availableLLMTools = { ...getBaseLLMTools() }; // Reset tools to base
            logMessage("LLM Unloaded.", 'llm');
            updateLLMControls();
        }

        function getBaseLLMTools() {
             // Define the initial tool_creation_tool available to the LLM
             return {
                 'tool_creation_tool': {
                     description: "Creates a new tool (artifact ability) for the Abyss LLM. Takes a 'name' for the tool and a 'description' of what the tool should do as a javascript function. The function should accept a single object argument containing named parameters.",
                     parameters: { // Describe parameters for the LLM
                         type: "object",
                         properties: {
                             name: { type: "string", description: "The name of the new tool/function to create." },
                             description: { type: "string", description: "A detailed description of what the new tool's javascript function should accomplish." },
                             // We might need the LLM to also specify the parameters the *new* function will take
                             // For now, let's assume the LLM includes parameter descriptions in the main description.
                         },
                         required: ["name", "description"]
                     },
                     function: async (args) => { // The JS function that executes the tool call
                         logMessage(`Executing tool_creation_tool: Name='${args.name}', Desc='${args.description}'`, 'llm');
                         playSound('tool_create');
                         if (!args.name || !args.description) {
                             return "Error: Missing 'name' or 'description' for tool_creation_tool.";
                         }
                         if (availableLLMTools[args.name]) {
                             return `Error: A tool named '${args.name}' already exists.`;
                         }

                         // Ask the LLM to generate the JS code for the new tool
                         const creationPrompt = `Generate the JavaScript code for a new tool named '${args.name}'.
The tool should do the following: ${args.description}.
The function must accept a single object argument (e.g., 'params') containing named parameters.
Only output the raw JavaScript code for the function body inside a \`\`\`javascript block. Do not include the function signature itself, just the body.
Example: If the description is 'adds two numbers x and y', the output should be:
\`\`\`javascript
if (typeof params.x !== 'number' || typeof params.y !== 'number') { return 'Error: x and y must be numbers.'; }
return params.x + params.y;
\`\`\`
Now, generate the code for '${args.name}':`;

                         try {
                             const codeResponse = await sendAbyssMessage([{ role: 'user', content: creationPrompt }], true); // Internal call, don't show user

                             // Extract JS code from the response
                             const codeMatch = codeResponse.match(/```javascript\s*([\s\S]*?)\s*```/);
                             if (!codeMatch || !codeMatch[1]) {
                                 logMessage("LLM failed to generate valid JS code for the new tool.", 'error');
                                 return "Error: Could not generate JavaScript code for the new tool.";
                             }
                             const functionBody = codeMatch[1].trim();

                             // Create the new function safely using new Function()
                             // We need to figure out the parameters the function expects.
                             // Let's ask the LLM for that too, or parse the description/code? Risky.
                             // Simplification: Assume the LLM description includes needed params, and the generated code uses `params.paramName`.
                             const newToolFunction = new Function('params', functionBody);

                             // Ask LLM to generate the parameter definition for the *new* tool
                             const paramPrompt = `Based on the description "${args.description}" and the generated code, define the JSON schema for the parameters object that the new tool '${args.name}' expects.
Output *only* the JSON schema object inside a \`\`\`json block.
Example for 'adds two numbers x and y':
\`\`\`json
{
  "type": "object",
  "properties": {
    "x": { "type": "number", "description": "First number" },
    "y": { "type": "number", "description": "Second number" }
  },
  "required": ["x", "y"]
}
\`\`\`
Now, generate the JSON schema for '${args.name}':`;

                             const paramResponse = await sendAbyssMessage([{ role: 'user', content: paramPrompt }], true);
                             const paramMatch = paramResponse.match(/```json\s*([\s\S]*?)\s*```/);
                             let newToolParamsSchema = { type: "object", properties: {} }; // Default empty schema
                             if (paramMatch && paramMatch[1]) {
                                 try {
                                     newToolParamsSchema = JSON.parse(paramMatch[1].trim());
                                 } catch (e) {
                                     logMessage(`Failed to parse JSON schema for new tool ${args.name}: ${e}`, 'error');
                                     return `Error: Failed to parse parameter schema for new tool ${args.name}. Tool not created.`;
                                 }
                             } else {
                                 logMessage(`LLM did not provide a valid parameter schema for ${args.name}. Using default.`, 'warning');
                             }


                             // Add the new tool to the available tools
                             availableLLMTools[args.name] = {
                                 description: args.description,
                                 parameters: newToolParamsSchema,
                                 function: newToolFunction
                             };

                             logMessage(`Successfully created and added new tool: ${args.name}`, 'llm');

                             // Create the corresponding artifact in the world
                             // Find a suitable location (maybe near player?)
                             const playerPos = player?.mesh?.position || new THREE.Vector3(0,0,0);
                             const artifactPos = {
                                 x: playerPos.x + (Math.random() - 0.5) * 10,
                                 y: 0.5,
                                 z: playerPos.z + (Math.random() - 0.5) * 10
                             };
                             // Clamp position to arena
                             const dist = Math.sqrt(artifactPos.x**2 + artifactPos.z**2);
                             if (dist > ARENA_RADIUS - 2) {
                                 artifactPos.x = (artifactPos.x / dist) * (ARENA_RADIUS - 2);
                                 artifactPos.z = (artifactPos.z / dist) * (ARENA_RADIUS - 2);
                             }

                             // For now, new tools don't automatically become physical artifacts
                             // Let's just make the tool available in chat.
                             // createArtifact(args.name, artifactPos); // Maybe later? How to link function?

                             return `New tool '${args.name}' created successfully and is now available for use.`;

                         } catch (error) {
                             logMessage(`Error during tool creation process: ${error}`, 'error');
                             return `Error creating tool '${args.name}'.`;
                         }
                     }
                 }
                 // Add other base tools if needed, e.g., 'get_player_status', 'list_nearby_artifacts'
             };
        }

        function formatToolsForLLM() {
            let toolPrompt = "You have access to the following tools. To use a tool, respond *only* with a JSON object matching the tool's parameter schema, enclosed in a special block like this: <tool_call name='tool_name'>```json\n{ \"param1\": \"value1\", ... }\n```</tool_call>. Do not add any other text before or after the tool call block if you decide to use a tool.\n\nAvailable Tools:\n";
            for (const name in availableLLMTools) {
                const tool = availableLLMTools[name];
                toolPrompt += `- ${name}:\n`;
                toolPrompt += `  Description: ${tool.description}\n`;
                toolPrompt += `  Parameters (JSON Schema): ${JSON.stringify(tool.parameters)}\n`;
            }
            return toolPrompt;
        }

        async function sendAbyssMessage(messages, internalCall = false) {
            if (!llmReady || llmLoading) {
                logMessage("LLM is not ready.", 'error');
                return "LLM not available.";
            }
            if (!internalCall) {
                logMessage("Sending message to Abyss...", 'llm');
            }

            const temperature = parseFloat(llmTemperatureSlider.value);
            let responseText = "";

            // Prepare messages for the specific LLM engine
            let llmPayload;

             // Add tool definitions before the last user message, but don't store them in history
             const toolDefinitions = formatToolsForLLM();
             const messagesWithTools = [...messages];
             if (messagesWithTools.length > 0) {
                 const lastUserMessage = messagesWithTools.pop();
                 // Inject tool info as a pseudo-system message (or assistant context)
                 // We'll use a user role here as 'system' isn't always reliable/supported
                 messagesWithTools.push({ role: 'user', content: `--- TOOL DEFINITIONS ---\n${toolDefinitions}\n--- END TOOL DEFINITIONS ---` });
                 messagesWithTools.push(lastUserMessage);
             } else {
                 // Should not happen in normal chat flow
                 messagesWithTools.push({ role: 'user', content: `--- TOOL DEFINITIONS ---\n${toolDefinitions}\n--- END TOOL DEFINITIONS ---` });
             }


            try {
                if (llmType === 'webllm') {
                    // Check if model is DeepSeek-R1 for special handling
                    const isDeepSeekR1 = llmModelId.toLowerCase().includes('deepseek-r1');

                    // WebLLM chat completions create expects specific format
                     const webLlmMessages = messagesWithTools.map(msg => ({ role: msg.role, content: msg.content }));

                     // Add <think> tag for DeepSeek-R1 if needed (though we expect it from model)
                     // The model itself should generate <think>, we just need to handle it in response.

                    const response = await llmEngine.chat.completions.create({
                        messages: webLlmMessages,
                        temperature: temperature,
                        stream: false, // Keep stream false for easier tool parsing initially
                        // tools: not using native tools here
                    });
                    responseText = response.choices[0]?.message?.content || "";

                    // Handle potential <think> tag from DeepSeek-R1
                     if (isDeepSeekR1 && responseText.startsWith("<think>")) {
                         // Find the end of the think block if necessary, or just log/ignore it
                         const thinkEndIndex = responseText.indexOf("</think>"); // Assuming it exists
                         if (thinkEndIndex !== -1) {
                             const thought = responseText.substring("<think>".length, thinkEndIndex).trim();
                             logMessage(`LLM Thought: ${thought}`, 'llm');
                             responseText = responseText.substring(thinkEndIndex + "</think>".length).trim();
                         } else {
                             // If no closing tag, maybe just remove the opening tag? Or log warning.
                             logMessage("DeepSeek-R1 started with <think> but no closing tag found.", "warning");
                             responseText = responseText.substring("<think>".length).trim();
                         }
                     }


                } else if (llmType === 'llmjs') {
                    // Format for llm.js based on model type (ChatML for Qwen, specific for DeepSeek)
                    const isDeepSeekR1 = llmModelId.toLowerCase().includes('deepseek-r1');
                    let promptString = "";

                    if (isDeepSeekR1) {
                        // DeepSeek-R1 GGUF Template: <User>\n{prompt}<Assistant>\n
                         messagesWithTools.forEach(msg => {
                             if (msg.role === 'user') {
                                 promptString += `<User>\n${msg.content}`;
                             } else if (msg.role === 'assistant') {
                                 promptString += `<Assistant>\n${msg.content}`;
                             }
                             // Ignore other roles for this template?
                         });
                         promptString += "<Assistant>\n"; // Prompt for assistant response
                    } else { // Assume ChatML for Qwen 2.5
                        // <|im_start|>system\n{system_message}<|im_end|>\n<|im_start|>user\n{prompt}<|im_end|>\n<|im_start|>assistant\n
                         messagesWithTools.forEach(msg => {
                             promptString += `<|im_start|>${msg.role}\n${msg.content}<|im_end|>\n`;
                         });
                         promptString += `<|im_start|>assistant\n`;
                    }

                    // Need a way to capture the response from llm.js's callback
                    let resolveResponse;
                    const responsePromise = new Promise(resolve => { resolveResponse = resolve; });

                    llmJsInstance.write_result = (text) => {
                        // Accumulate text? llm.js might call this multiple times for streaming.
                        // For non-streaming simulation:
                        responseText += text; // Append results
                        // We need a way to know when it's finished. The run_complete callback helps.
                    };
                    llmJsInstance.run_complete = () => {
                         logMessage("llm.js generation finished.", 'llm');
                         // Handle potential <think> tag from DeepSeek-R1
                         if (isDeepSeekR1 && responseText.startsWith("<think>")) {
                             const thinkEndIndex = responseText.indexOf("</think>");
                             if (thinkEndIndex !== -1) {
                                 const thought = responseText.substring("<think>".length, thinkEndIndex).trim();
                                 logMessage(`LLM Thought: ${thought}`, 'llm');
                                 responseText = responseText.substring(thinkEndIndex + "</think>".length).trim();
                             } else {
                                 responseText = responseText.substring("<think>".length).trim();
                             }
                         }
                         resolveResponse(responseText); // Resolve the promise when generation is complete
                    };

                    llmJsInstance.run({
                        prompt: promptString,
                        temperature: temperature,
                        top_k: 40, // Example parameters for llm.js
                        // Add other relevant parameters if needed
                    });

                    responseText = await responsePromise; // Wait for the run_complete callback

                } else {
                    responseText = "Selected LLM API not implemented.";
                }

                if (!internalCall) logMessage(`Abyss Raw Response: ${responseText}`, 'llm');

                // --- Custom Tool Call Parsing ---
                // Look for <tool_call name='tool_name'>```json ... ```</tool_call>
                const toolCallRegex = /<tool_call name='([^']+)'>\s*```json\s*([\s\S]*?)\s*```\s*<\/tool_call>/;
                const match = responseText.match(toolCallRegex);

                if (match) {
                    const toolName = match[1];
                    const toolArgsJson = match[2].trim();
                    logMessage(`Detected tool call for: ${toolName}`, 'llm');

                    if (availableLLMTools[toolName]) {
                        try {
                            const toolArgs = JSON.parse(toolArgsJson);
                            logMessage(`Calling tool ${toolName} with args: ${JSON.stringify(toolArgs)}`, 'llm');

                            // Execute the tool function (can be async)
                            const toolResult = await availableLLMTools[toolName].function(toolArgs);
                            logMessage(`Tool ${toolName} result: ${toolResult}`, 'llm');

                            // We need to send the result back to the LLM to get a final response
                            // Add the tool call and result to the history/context and resend
                            const messagesWithToolResult = [
                                ...messages, // Original messages
                                { role: 'assistant', content: responseText }, // LLM's response containing the tool call
                                { role: 'user', content: `--- TOOL RESULT for ${toolName} ---\n${toolResult}\n--- END TOOL RESULT ---` } // Result (using user role as 'tool' role isn't standard/used here)
                            ];
                             // Prevent infinite loops if tool call fails repeatedly
                             // Add a counter or check history depth? For jam, maybe just proceed.

                            // Resend to LLM with the tool result included
                            return await sendAbyssMessage(messagesWithToolResult, internalCall);

                        } catch (e) {
                            logMessage(`Error parsing tool arguments or executing tool ${toolName}: ${e}`, 'error');
                            return `Error processing tool call: ${e.message}`;
                        }
                    } else {
                        logMessage(`LLM tried to call unknown tool: ${toolName}`, 'error');
                        return `Error: Unknown tool '${toolName}'.`;
                    }
                } else {
                    // No tool call detected, this is the final response
                    return responseText;
                }

            } catch (error) {
                logMessage(`Error during LLM communication: ${error}`, 'error');
                 // Retry logic?
                 // For now, just return error message.
                 // Don't invent fake moves - just report error.
                 await new Promise(resolve => setTimeout(resolve, 1000)); // Wait a bit before potentially retrying
                 // Simple retry once:
                 // TODO: Implement better retry logic if needed
                 // try { ... } catch { return "LLM Error"; }

                return `Abyss communication error: ${error.message}`;
            }
        }

        async function handleChatSubmit() {
            const message = chatInput.value.trim();
            if (!message || !llmReady) return;

            logMessage(`Player: ${message}`, 'user');
            chatInput.value = '';

            // Add user message to history
            chatHistory.push({ role: 'user', content: message });
            if (chatHistory.length > MAX_CHAT_HISTORY) {
                chatHistory.shift(); // Remove oldest message
            }

            // Special handling for tool_creation_tool usage via chat
            let isToolCreationCommand = false;
            if (player && player.hasAbility('tool_creation_tool')) {
                 // Check if the player is trying to use the tool
                 // Example command: /create_tool name="Spawn Creature" description="Creates a basic creature near the player"
                 const createToolMatch = message.match(/^\/create_tool\s+name="([^"]+)"\s+description="([^"]+)"/i);
                 if (createToolMatch) {
                     isToolCreationCommand = true;
                     const toolName = createToolMatch[1];
                     const toolDescription = createToolMatch[2];
                     logMessage(`Player using tool_creation_tool artifact to create: ${toolName}`, 'llm');

                     // Manually call the base tool_creation_tool function
                     const creationResult = await availableLLMTools.tool_creation_tool.function({ name: toolName, description: toolDescription });
                     logMessage(`Abyss (Tool Creation): ${creationResult}`, 'llm');
                     chatHistory.push({ role: 'assistant', content: creationResult }); // Add result to history
                 }
            }


            if (!isToolCreationCommand) {
                 // Send history to LLM and get response
                 const response = await sendAbyssMessage(chatHistory);
                 logMessage(`Abyss: ${response}`, 'llm');

                 // Add assistant response to history
                 chatHistory.push({ role: 'assistant', content: response });
                 if (chatHistory.length > MAX_CHAT_HISTORY) {
                     chatHistory.shift();
                 }
            }
        }

        // --- UI Updates ---
        function updatePlayerUI() {
            // Update button states based on available artifacts
            attackMeleeButton.disabled = !(player?.hasAbility('attack_melee'));
            attackRangeButton.disabled = !(player?.hasAbility('attack_range'));
            // Interact button always enabled? Or needs 'see'? Let's say always enabled.
            // interactButton.disabled = !(player?.hasAbility('see'));

            attackMeleeButton.style.opacity = attackMeleeButton.disabled ? 0.5 : 1;
            attackRangeButton.style.opacity = attackRangeButton.disabled ? 0.5 : 1;
            // interactButton.style.opacity = interactButton.disabled ? 0.5 : 1;

             // Maybe display current artifacts?
             // const artifactList = player ? Array.from(player.artifacts.keys()).join(', ') : 'None';
             // logMessage(`Player Artifacts: [${artifactList}]`, 'ui'); // Log instead of UI clutter for now
        }

        // --- Game Setup ---
        function setupInitialWorld() {
            logMessage("Setting up initial world state (Non-LLM)...", 'system');

            // Player
            player = new Entity('player_0', { x: 0, y: 1, z: ARENA_RADIUS * 0.8 }, true); // Start near edge
            const startMove = createArtifact('move', { x: player.mesh.position.x + 1, y: 0.5, z: player.mesh.position.z });
            const startSee = createArtifact('see', { x: player.mesh.position.x - 1, y: 0.5, z: player.mesh.position.z });
            player.addArtifact(startMove);
            player.addArtifact(startSee);

            // Goal Artifact
            createArtifact('tool_creation_tool', { x: 0, y: 0.5, z: -ARENA_RADIUS * 0.9 }); // Place at opposite side near center

            // Other Artifacts (Scattered)
            for (let i = 0; i < 20; i++) {
                createArtifact(); // Create random artifact at random position
            }

            // Enemies (Different levels/circles)
            const numEnemies = 10;
            for (let i = 0; i < numEnemies; i++) {
                const level = Math.floor(i / (numEnemies / 3)); // 0, 1, 2
                const radius = ARENA_RADIUS * (0.6 - level * 0.2); // Closer to center for higher levels
                const angle = Math.random() * Math.PI * 2;
                const pos = { x: Math.cos(angle) * radius, y: 1, z: Math.sin(angle) * radius };
                const enemy = new Entity(`creature_${entityIdCounter++}`, pos);

                // Give enemies basic artifacts based on level
                enemy.addArtifact(createArtifact('move', { ...pos, y: 0.5, x: pos.x + 0.5 }));
                enemy.addArtifact(createArtifact('see', { ...pos, y: 0.5, x: pos.x - 0.5 }));
                if (level >= 0) { // All enemies get melee
                     enemy.addArtifact(createArtifact('attack_melee', { ...pos, y: 0.5, z: pos.z + 0.5 }));
                }
                 if (level >= 1 && Math.random() < 0.5) { // Level 1+ have chance for range
                     enemy.addArtifact(createArtifact('attack_range', { ...pos, y: 0.5, z: pos.z - 0.5 }));
                 }
                 // Level 2 enemies are just tougher by default (more HP implicitly via artifacts)
                 // Or we could add HP scaling later.
            }

            logMessage("Initial world setup complete.", 'system');
            updatePlayerUI();
        }

        // --- Main Initialization ---
        async function init() {
            logMessage("Initializing Abyss Arena...", 'system');
            loadingOverlay.textContent = "Initializing Graphics...";
            // Basic Three.js Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, ARENA_RADIUS * 1.1); // Start further back
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows if lights are added
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 1); // Soft ambient light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Physics
            loadingOverlay.textContent = "Initializing Physics...";
            await initPhysics();

            // Arena
            loadingOverlay.textContent = "Building Arena...";
            setupArena();

            // Controls
            loadingOverlay.textContent = "Setting up Controls...";
            initControls(); // Includes touch, keyboard, gamepad listeners

             // LLM Setup UI Listeners
             llmEngineSelect.addEventListener('change', updateLLMControls);
             webllmModelSelect.addEventListener('change', () => { /* Maybe prompt reload */ });
             llmjsModelSelect.addEventListener('change', () => { /* Maybe prompt reload */ });
             loadLlmButton.addEventListener('click', loadLLM);
             llmTemperatureSlider.addEventListener('input', () => {
                 temperatureValueSpan.textContent = llmTemperatureSlider.value;
             });
             chatInput.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter' && !e.shiftKey) {
                     e.preventDefault();
                     handleChatSubmit();
                 }
             });
             sendChatButton.addEventListener('click', handleChatSubmit);
             updateLLMControls(); // Initial UI state

             // Initial Tools
             availableLLMTools = { ...getBaseLLMTools() };


            // Pre-create world content for instant playability
            loadingOverlay.textContent = "Populating Abyss...";
            setupInitialWorld();

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start the game loop
            loadingOverlay.style.display = 'none'; // Hide loading screen
            logMessage("Initialization Complete. Starting Game Loop.", 'system');
            animate();
        }

        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // Process Input
            processInput(deltaTime);

            // Step Physics World
            if (physicsWorld) {
                physicsWorld.step(eventQueue);
                handleCollisions(); // Process collisions after step
            }

            // Update Entities (includes syncing physics to graphics, AI)
            entities.forEach(entity => entity.update(deltaTime));

            // Update non-entity meshes (like projectiles)
             physicsWorld?.colliders.forEach(collider => {
                 if (collider.userData?.type === 'projectile' && collider.userData.mesh) {
                     const body = collider.parent();
                     if (body) {
                         collider.userData.mesh.position.copy(body.translation());
                         collider.userData.mesh.quaternion.copy(body.rotation());
                     }
                 }
             });

            // Update Camera (Simple third-person follow)
            if (player && player.mesh) {
                const offset = new THREE.Vector3(0, 3, 5); // Behind and slightly above
                const desiredPosition = player.mesh.position.clone().add(offset.applyQuaternion(player.mesh.quaternion));
                camera.position.lerp(desiredPosition, 0.1); // Smooth follow
                const lookAtTarget = player.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)); // Look slightly above player base
                camera.lookAt(lookAtTarget);
            }

             // Enforce Arena Boundaries (simple pushback if physics wall fails)
             entities.forEach(entity => {
                 const pos = entity.mesh.position;
                 const distSq = pos.x * pos.x + pos.z * pos.z;
                 if (distSq > ARENA_RADIUS * ARENA_RADIUS) {
                     const dist = Math.sqrt(distSq);
                     const correctionFactor = ARENA_RADIUS / dist;
                     const correctedPos = { x: pos.x * correctionFactor, y: pos.y, z: pos.z * correctionFactor };
                     entity.rigidBody.setTranslation(correctedPos, true); // Teleport back in slightly
                     // Optionally apply opposing impulse?
                 }
                 // Keep entities above ground
                 if (pos.y < 0.3 && entity.rigidBody) {
                    entity.rigidBody.setTranslation({x: pos.x, y: 0.3, z: pos.z}, true);
                    entity.rigidBody.setLinvel({x:0, y:0, z:0}, true); // Stop downward velocity
                 }
             });


            // Render Scene
            renderer.render(scene, camera);
        }

        // --- Start ---
        init().catch(err => {
            console.error("Initialization failed:", err);
            logMessage(`Critical Error during Initialization: ${err}`, 'error');
            loadingOverlay.textContent = `Error: ${err.message}. Please refresh.`;
            loadingOverlay.style.display = 'flex';
        });

    </script>
</body>
</html>

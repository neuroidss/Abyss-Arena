<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Abyss Arena - Dev Build</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: 'system-ui', sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas/nipplejs */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #messages {
            background: rgba(0,0,0,0.5);
            padding: 5px;
            max-height: 20vh;
            overflow-y: auto;
            pointer-events: all; /* Allow interaction with messages */
            margin-bottom: auto; /* Pushes controls down */
             color: #eee;
             font-size: 14px;
             border-bottom: 1px solid #444;
             scrollbar-width: thin;
             scrollbar-color: #555 #333;
        }
        #messages div { margin-bottom: 3px; word-wrap: break-word; }
        #controls-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* Align items to the bottom */
            padding: 10px;
            pointer-events: none; /* Reset for children */
             height: 150px; /* Ensure space for joysticks */
        }
         #joystick-left, #joystick-right {
            position: relative; /* Needed for nipplejs */
            width: 100px;
            height: 100px;
            background: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            pointer-events: all;
        }
        #action-buttons {
             display: flex;
             flex-direction: column;
             align-items: center;
             pointer-events: all;
        }
        .action-button {
            background: rgba(80, 80, 80, 0.7);
            color: white;
            border: 1px solid #aaa;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            text-align: center;
        }
         .action-button:active {
             background: rgba(120, 120, 120, 0.8);
         }
         .action-button:disabled {
             opacity: 0.5;
             cursor: not-allowed;
         }

        #llm-controls {
            position: fixed;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: all;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
            max-height: 90vh; /* Prevent controls overlapping messages too much */
            overflow-y: auto; /* Allow scrolling if controls get too long */
            scrollbar-width: thin;
            scrollbar-color: #555 #333;
        }
         #llm-controls label, #llm-controls select, #llm-controls button, #llm-controls input {
             display: block;
             margin-bottom: 3px;
         }
         #llm-controls button {
             padding: 3px 6px;
             cursor: pointer;
         }
         #llm-controls button:disabled {
             cursor: not-allowed;
             opacity: 0.6;
         }
         #llm-chat {
             margin-top: 10px;
             display: flex;
             gap: 5px;
         }
         #llm-chat input { flex-grow: 1; }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 10001; /* Above jam link */
        }
        #demo-controls, #debug-controls {
            margin-top: 10px;
            border-top: 1px solid #555;
            padding-top: 5px;
        }
        #debug-controls button {
             margin-right: 5px;
         }
    </style>
</head>
<body>
    <div id="loading-overlay">Loading Assets...</div>
    <div id="messages"></div>
    <div id="ui-container">
        <!-- Messages div is dynamically positioned by flexbox -->
        <div></div> <!-- Spacer -->
        <div id="controls-area">
             <div id="joystick-left"></div>
             <div id="action-buttons">
                 <button id="attack-melee-button" class="action-button">Melee</button>
                 <button id="attack-range-button" class="action-button">Range</button>
                 <button id="interact-button" class="action-button">Pick</button>
             </div>
             <div id="joystick-right"></div>
        </div>
    </div>
    <div id="llm-controls">
        <label for="llm-engine-select">LLM Engine:</label>
        <select id="llm-engine-select">
            <option value="none">None</option>
            <option value="webllm">WebLLM (WebGPU)</option>
            <option value="llmjs">llm.js (CPU)</option>
            <!-- <option value="openai">OpenAI API</option> -->
            <!-- <option value="gemini">Gemini API</option> -->
            <!-- <option value="claude">Claude API</option> -->
            <!-- <option value="ollama">Ollama API</option> -->
        </select>
         <div id="webllm-options" style="display: none;">
             <label for="webllm-model-select">WebLLM Model:</label>
             <select id="webllm-model-select">
                 <option value="Qwen2.5-Coder-3B-Instruct-q4f32_1-MLC">Qwen2.5-Coder-3B</option>
                 <option value="Qwen2.5-Coder-7B-Instruct-q4f32_1-MLC" selected>Qwen2.5-Coder-7B</option>
                 <option value="DeepSeek-R1-Distill-Qwen-7B-q4f32_1-MLC">DeepSeek-R1-Distill-Qwen-7B</option>
             </select>
         </div>
         <div id="llmjs-options" style="display: none;">
             <label for="llmjs-model-select">llm.js Model:</label>
             <select id="llmjs-model-select">
                 <option value="https://huggingface.co/unsloth/Qwen2.5-Coder-3B-Instruct-128K-GGUF/resolve/main/Qwen2.5-Coder-3B-Instruct-Q4_K_M.gguf">Qwen2.5-Coder-3B</option>
                 <option value="https://huggingface.co/unsloth/Qwen2.5-Coder-7B-Instruct-128K-GGUF/resolve/main/Qwen2.5-Coder-7B-Instruct-Q4_K_M.gguf" selected>Qwen2.5-Coder-7B</option>
                 <option value="https://huggingface.co/unsloth/DeepSeek-R1-Distill-Qwen-7B-GGUF/resolve/main/DeepSeek-R1-Distill-Qwen-7B-Q4_K_M.gguf">DeepSeek-R1-Distill-Qwen-7B</option>
                 <!-- Add other sizes if needed -->
                 <!-- <option value="https://huggingface.co/unsloth/Qwen2.5-Coder-14B-Instruct-128K-GGUF/resolve/main/Qwen2.5-Coder-14B-Instruct-Q4_K_M.gguf">Qwen2.5-Coder-14B</option> -->
                 <!-- <option value="https://huggingface.co/unsloth/DeepSeek-R1-Distill-Qwen-1.5B-GGUF/resolve/main/DeepSeek-R1-Distill-Qwen-1.5B-Q4_K_M.gguf">DeepSeek-R1-Distill-Qwen-1.5B</option> -->
                 <!-- <option value="https://huggingface.co/unsloth/DeepSeek-R1-Distill-Qwen-14B-GGUF/resolve/main/DeepSeek-R1-Distill-Qwen-14B-Q4_K_M.gguf">DeepSeek-R1-Distill-Qwen-14B</option> -->
             </select>
         </div>
         <button id="load-llm-button">Load/Switch LLM</button>
         <label for="llm-temperature">Temperature:</label>
         <input type="range" id="llm-temperature" min="0" max="1.5" step="0.1" value="0.7">
         <span id="temperature-value">0.7</span>

         <div id="llm-status">Status: Not Loaded</div>
         <div id="llm-chat" style="display: none;"> <!-- Hidden until LLM loaded -->
            <input type="text" id="chat-input" placeholder="Chat with Abyss...">
            <button id="send-chat-button">Send</button>
         </div>

         <div id="demo-controls">
             <button id="toggle-demo-button">Enable Demo Mode</button>
             <div id="demo-status" style="font-size: 11px; margin-top: 3px;">Demo: OFF</div>
         </div>

         <div id="debug-controls">
             <button id="start-recording-button">Start Rec</button>
             <button id="stop-recording-button" disabled>Stop Rec & Save</button>
             <div id="recording-status" style="font-size: 11px; margin-top: 3px;">Rec: OFF</div>
         </div>
    </div>

    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;"> Vibe Jam 2025</a>

    <script type="module">
        // Imports
        import * as THREE from 'https://esm.run/three@0.160.0';
        import nipplejs from 'https://esm.run/nipplejs@0.10.1';
        import RAPIER from 'https://esm.run/@dimforge/rapier3d-compat@0.12.0'; // Use compat version
        import * as webllm from "https://esm.run/@mlc-ai/web-llm"; // Lazy load later?
        // LLM.js will be imported conditionally if needed

        console.log("Starting Abyss Arena...");

        // --- Global State ---
        let scene, camera, renderer, clock;
        let physicsWorld, eventQueue;
        let player = null; // Will hold player entity data
        const entities = new Map(); // Map<entityId, entityData>
        const artifacts = new Map(); // Map<artifactId, artifactData>
        let entityIdCounter = 0;
        let artifactIdCounter = 0;
        const ARENA_RADIUS = 50;
        const ARENA_HEIGHT = 10;
        const MAX_ARTIFACT_LIFETIME = 5 * 60 * 1000; // 5 minutes in milliseconds

        // LLM State
        let llmEngine = null;
        let llmType = 'none'; // 'none', 'webllm', 'llmjs', 'openai', etc.
        let llmModelId = '';
        let llmLoading = false;
        let llmReady = false;
        let chatHistory = [];
        const MAX_CHAT_HISTORY = 20; // Limit history size
        let availableLLMTools = {}; // { toolName: { description: string, function: Function, parameters: object } }
        let llmJsInstance = null; // For llm.js

        // Input State
        const inputState = {
            moveForward: 0, moveBackward: 0, moveLeft: 0, moveRight: 0,
            rotateLeft: 0, rotateRight: 0, rotateUp: 0, rotateDown: 0,
            actionMelee: false, actionRange: false, actionInteract: false,
            touchMove: { x: 0, y: 0 }, touchLook: { x: 0, y: 0 },
            gamepadConnected: false
        };
        let moveJoystick = null;
        let lookJoystick = null;

        // Demo State
        let demoModeActive = false;
        let demoState = 'WANDER'; // Initial demo state
        let demoTargetEntity = null;
        let demoTargetArtifact = null;
        let demoStateTimer = 0;
        const DEMO_STATE_TIMEOUT = 5; // Seconds before potentially changing state

        // Recording State
        let isRecording = false;
        let recordedFrames = [];
        let recordedEvents = [];
        let frameCounter = 0;

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const loadingOverlay = document.getElementById('loading-overlay');
        const llmEngineSelect = document.getElementById('llm-engine-select');
        const webllmOptionsDiv = document.getElementById('webllm-options');
        const llmjsOptionsDiv = document.getElementById('llmjs-options');
        const webllmModelSelect = document.getElementById('webllm-model-select');
        const llmjsModelSelect = document.getElementById('llmjs-model-select');
        const loadLlmButton = document.getElementById('load-llm-button');
        const llmStatusDiv = document.getElementById('llm-status');
        const llmChatDiv = document.getElementById('llm-chat');
        const chatInput = document.getElementById('chat-input');
        const sendChatButton = document.getElementById('send-chat-button');
        const llmTemperatureSlider = document.getElementById('llm-temperature');
        const temperatureValueSpan = document.getElementById('temperature-value');
        const attackMeleeButton = document.getElementById('attack-melee-button');
        const attackRangeButton = document.getElementById('attack-range-button');
        const interactButton = document.getElementById('interact-button');
        const toggleDemoButton = document.getElementById('toggle-demo-button');
        const demoStatusDiv = document.getElementById('demo-status');
        const startRecordingButton = document.getElementById('start-recording-button');
        const stopRecordingButton = document.getElementById('stop-recording-button');
        const recordingStatusDiv = document.getElementById('recording-status');


        // --- Helper Functions ---
        function logMessage(text, type = 'info') {
            console.log(`[${type.toUpperCase()}] ${text}`);
            if (type === 'demo' && !demoModeActive && !isRecording) return; // Don't log demo if not active/recording

            const div = document.createElement('div');
            div.textContent = text;
            let color = '#eee'; // Default info color
            switch(type) {
                case 'error': color = 'red'; break;
                case 'llm': color = 'cyan'; break;
                case 'warning': color = 'orange'; break;
                case 'demo': color = '#9f8'; break; // Light green
                case 'user': color = '#8af'; break; // Light blue
                case 'combat': color = '#f99'; break; // Light red
                case 'game': color = '#fff'; break; // White for general game events
                case 'system': color = '#aaa'; break; // Grey for system
                case 'pickup': color = '#afa'; break; // Light green for pickup
                case 'destroy': color = '#faa'; break; // Light red for destroy
            }
            div.style.color = color;
            messagesDiv.appendChild(div);
            // Limit message count
            while (messagesDiv.children.length > 100) {
                messagesDiv.removeChild(messagesDiv.firstChild);
            }
            messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll

            // Log significant events to recording if active
            if (isRecording && ['error', 'warning', 'combat', 'game', 'pickup', 'destroy', 'user', 'llm'].includes(type)) {
                 logEvent('message', { type: type, text: text });
            }
        }

        function logEvent(eventType, data) {
            if (!isRecording) return;
            // Avoid logging excessively large objects directly if possible
            const cleanData = JSON.parse(JSON.stringify(data)); // Basic deep clone to avoid issues with mutable objects
            recordedEvents.push({
                frame: frameCounter,
                timestamp: Date.now(),
                eventType: eventType,
                data: cleanData
            });
        }

        function generateUUID() { // Simple UUID for IDs
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Simple sound generation
        let audioCtx;
        function playSound(type = 'click', volume = 0.1, duration = 0.05) {
            if (!audioCtx) {
                try {
                    // Request AudioContext on first user interaction (e.g., button click) if needed for autoplay policies
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API not supported.");
                    return;
                }
            }
            if (!audioCtx || audioCtx.state === 'suspended') {
                // Attempt to resume if suspended (often requires user gesture)
                audioCtx.resume().catch(e => console.warn("Could not resume AudioContext:", e));
                if (audioCtx.state !== 'running') return; // Still not running, exit
            }


            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            switch(type) {
                case 'pickup': oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); break; // A5
                case 'hit_melee': oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); break; // A3
                case 'hit_range': oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); break; // A4
                case 'destroy': oscillator.frequency.setValueAtTime(110, audioCtx.currentTime); break; // A2
                case 'error': oscillator.frequency.setValueAtTime(164, audioCtx.currentTime); oscillator.type = 'sawtooth'; break; // E3
                case 'tool_create': oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime); duration = 0.3; break;
                default: oscillator.frequency.setValueAtTime(660, audioCtx.currentTime); break; // E5 (click)
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // --- Entity & Artifact Management ---
        class Entity {
            constructor(id, position = { x: 0, y: 1, z: 0 }, isPlayer = false) {
                this.id = id;
                this.isPlayer = isPlayer;
                this.soul = isPlayer ? 'player_soul' : `npc_soul_${id}`;
                this.mesh = new THREE.Group();
                this.bodyMesh = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.4, 1.0),
                    new THREE.MeshStandardMaterial({ color: isPlayer ? 0x00ff00 : 0xff0000 })
                );
                this.bodyMesh.position.y = 0.9;
                this.mesh.add(this.bodyMesh);
                this.mesh.position.set(position.x, position.y, position.z);
                scene.add(this.mesh);

                // Physics Body
                const rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(position.x, position.y, position.z)
                    .setLinearDamping(0.5)
                    .setAngularDamping(1.0);
                this.rigidBody = physicsWorld.createRigidBody(rigidBodyDesc);
                const colliderDesc = RAPIER.ColliderDesc.capsule(0.5, 0.4)
                    .setRestitution(0.1)
                    .setFriction(0.5)
                    .setDensity(1.0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); // Enable collision events for entities
                this.collider = physicsWorld.createCollider(colliderDesc, this.rigidBody);
                this.collider.userData = { entityId: this.id, type: 'entity' };

                this.artifacts = new Map();
                this.hp = 100;
                this.lastMoveTime = Date.now();
                this.lastSeeTime = Date.now();
                this.lastAttackTime = 0;
                this.target = null;
                this.wanderTarget = null; // For AI wander state

                entities.set(this.id, this);
                logMessage(`Created ${isPlayer ? 'Player' : 'Creature'} ${this.id}`, 'game');
                 logEvent('entity_created', { entityId: this.id, isPlayer: isPlayer, position: [position.x, position.y, position.z] });
            }

            addArtifact(artifact) {
                if (!artifact || !artifact.abilityType || artifact.attachedTo) return false; // Check if already attached
                logMessage(`${this.id} trying to assemble ${artifact.id} (${artifact.abilityType})`, 'pickup');

                if (this.artifacts.has(artifact.abilityType)) {
                     const existingArtifact = this.artifacts.get(artifact.abilityType);
                     logMessage(`Upgrading ${artifact.abilityType}. Refreshing timer. Destroying ${artifact.id}.`, 'pickup');
                     existingArtifact.creationTime = Date.now();
                     logEvent('artifact_upgraded', { entityId: this.id, artifactType: artifact.abilityType, oldArtifactId: existingArtifact.id, consumedArtifactId: artifact.id });
                     destroyArtifact(artifact.id); // Destroy the new one after upgrading the old one
                     playSound('pickup');
                     if (this.isPlayer) updatePlayerUI();
                     return true;
                }

                this.artifacts.set(artifact.abilityType, artifact);
                artifact.attachedTo = this.id;
                const artifactMesh = artifacts.get(artifact.id)?.mesh;
                if (artifactMesh) {
                    // Make sure mesh is not parented elsewhere before adding
                    if(artifactMesh.parent) artifactMesh.parent.remove(artifactMesh);
                    this.mesh.add(artifactMesh);
                    // Position artifacts simply around the body
                    const angle = (this.artifacts.size * Math.PI / 4); // Example positioning
                    artifactMesh.position.set(Math.sin(angle) * 0.6, 1.0, Math.cos(angle) * 0.6);
                    artifactMesh.rotation.set(0,0,0); // Reset rotation relative to parent
                }
                logMessage(`${this.id} assembled ${artifact.id} (${artifact.abilityType})`, 'pickup');
                playSound('pickup');
                logEvent('artifact_pickup', { entityId: this.id, artifactId: artifact.id, abilityType: artifact.abilityType });

                if (this.isPlayer) updatePlayerUI();
                return true;
            }

            removeArtifact(abilityType, reason = 'unknown') {
                if (this.artifacts.has(abilityType)) {
                    const artifact = this.artifacts.get(abilityType);
                    logMessage(`${this.id} lost artifact ${artifact.id} (${abilityType}) due to ${reason}`, 'destroy');
                    logEvent('artifact_removed', { entityId: this.id, artifactId: artifact.id, abilityType: abilityType, reason: reason });
                    this.artifacts.delete(abilityType);
                    // Detach mesh (it will be removed by destroyArtifact later)
                    const artifactMesh = artifacts.get(artifact.id)?.mesh;
                    if (artifactMesh) {
                        this.mesh.remove(artifactMesh); // Remove from entity group
                    }
                    if (this.isPlayer) updatePlayerUI();
                    return artifact.id; // Return the artifact ID so it can be fully destroyed
                }
                return null;
            }

            hasAbility(abilityType) {
                return this.artifacts.has(abilityType);
            }

            getAbility(abilityType) {
                return this.artifacts.get(abilityType);
            }

            update(deltaTime) {
                // Sync mesh position with physics body
                if (!this.rigidBody || !physicsWorld.getRigidBody(this.rigidBody.handle)) {
                    console.warn(`Entity ${this.id} update called without valid rigidBody.`);
                    // Consider removing the entity if its body is gone unexpectedly
                    // entities.delete(this.id);
                    // scene.remove(this.mesh);
                    return;
                }
                const bodyPosition = this.rigidBody.translation();
                this.mesh.position.copy(bodyPosition);
                const bodyRotation = this.rigidBody.rotation();
                this.mesh.quaternion.set(bodyRotation.x, bodyRotation.y, bodyRotation.z, bodyRotation.w);

                // Basic AI for non-player entities
                if (!this.isPlayer) {
                    this.simpleAI(deltaTime);
                }

                // Check artifact expiration (Abyss reclaiming)
                const now = Date.now();
                const expiredTypes = [];
                for (const [type, artifact] of this.artifacts.entries()) {
                    if (now > artifact.creationTime + MAX_ARTIFACT_LIFETIME) {
                        let disassemble = false;
                        // Check usage - very basic check
                        if (type === 'move' && now > this.lastMoveTime + 30000) disassemble = true; // No move in 30s
                        if (type === 'see' && now > this.lastSeeTime + 60000) disassemble = true; // No look/scan in 60s

                        if (disassemble && Math.random() < 0.3) { // Chance to disassemble
                             expiredTypes.push(type);
                        } else if (disassemble) {
                            // Reset timer slightly if not disassembled (grace period)
                            artifact.creationTime = now - MAX_ARTIFACT_LIFETIME + 10000;
                        }
                    }
                }
                expiredTypes.forEach(type => {
                    const artifactId = this.removeArtifact(type, 'expired'); // Pass reason
                    if (artifactId) {
                        playSound('destroy');
                        destroyArtifact(artifactId, 'expired'); // Pass reason
                    }
                });

                 // Basic HP Regen if not recently hit? (Placeholder)
                 // this.hp = Math.min(100, this.hp + deltaTime * 1);
            }

            simpleAI(deltaTime) {
                // Rudimentary AI: Move randomly or towards player if close
                if (!player || !player.rigidBody) return; // No player or player invalid

                const distanceToPlayer = this.mesh.position.distanceTo(player.mesh.position);
                const aggroRadius = 15 + (ARENA_RADIUS - this.mesh.position.length()) * 0.2; // More aggro closer to center

                if (this.hasAbility('move')) {
                    let moveTargetPos = null;
                    if (distanceToPlayer < aggroRadius) {
                        moveTargetPos = player.mesh.position;
                        this.target = player; // Target player for attacks
                    } else {
                        this.target = null;
                        // Random wander (occasional change)
                        if (!this.wanderTarget || this.mesh.position.distanceTo(this.wanderTarget) < 2 || Math.random() < 0.01) {
                            const wanderAngle = Math.random() * Math.PI * 2;
                            const wanderDist = 5 + Math.random() * 10;
                            this.wanderTarget = new THREE.Vector3(
                                this.mesh.position.x + Math.cos(wanderAngle) * wanderDist,
                                this.mesh.position.y, // Keep same height level
                                this.mesh.position.z + Math.sin(wanderAngle) * wanderDist
                            );
                            // Clamp wander target to arena radius
                            const distFromCenter = Math.sqrt(this.wanderTarget.x**2 + this.wanderTarget.z**2);
                            if (distFromCenter > ARENA_RADIUS - 1) {
                                this.wanderTarget.x = (this.wanderTarget.x / distFromCenter) * (ARENA_RADIUS - 1);
                                this.wanderTarget.z = (this.wanderTarget.z / distFromCenter) * (ARENA_RADIUS - 1);
                            }
                        }
                        if (this.wanderTarget) {
                           moveTargetPos = this.wanderTarget;
                        }
                    }

                    if (moveTargetPos) {
                        const moveDir = new THREE.Vector3().subVectors(moveTargetPos, this.mesh.position);
                        moveDir.y = 0; // Don't move vertically
                        const distToTarget = moveDir.length();

                        if (distToTarget > 0.5) { // Only move if not already at target
                            moveDir.normalize();
                            const forceMagnitude = this.target ? 30 : 15; // Move faster towards player
                            const force = moveDir.multiplyScalar(forceMagnitude);
                            this.rigidBody.applyImpulse({ x: force.x * deltaTime, y: 0, z: force.z * deltaTime }, true);
                            this.lastMoveTime = Date.now();

                            // Rotate towards target
                            const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                                new THREE.Vector3(0, 0, 1), // Model's default forward Z+
                                new THREE.Vector3(moveDir.x, 0, moveDir.z).normalize() // Target direction in XZ plane
                            );
                             const currentRotation = this.rigidBody.rotation();
                             const currentQuaternion = new THREE.Quaternion(currentRotation.x, currentRotation.y, currentRotation.z, currentRotation.w);
                             currentQuaternion.slerp(targetQuaternion, 0.1); // Smooth rotation
                             this.rigidBody.setRotation(currentQuaternion, true);
                        }
                    }
                }

                 // Basic Attack AI
                 if (this.target && entities.has(this.target.id) && Date.now() > this.lastAttackTime + 2000) { // Cooldown & target valid
                     const attackDistance = this.mesh.position.distanceTo(this.target.mesh.position);
                     if (this.hasAbility('attack_melee') && attackDistance < 2.0) {
                         this.performAttack('attack_melee', this.target);
                     } else if (this.hasAbility('attack_range') && attackDistance < 20) {
                         this.performAttack('attack_range', this.target);
                     }
                 }

                 // Simulate 'seeing'
                 if (this.hasAbility('see') && Math.random() < 0.1) {
                     this.lastSeeTime = Date.now();
                 }
            }

            performAttack(type, targetEntity = null) {
                const cooldown = type === 'attack_melee' ? 500 : 1000;
                if (!this.hasAbility(type) || Date.now() < this.lastAttackTime + cooldown) {
                    return; // Check cooldown based on type
                }
                this.lastAttackTime = Date.now();
                const artifact = this.getAbility(type);
                const damage = type === 'attack_melee' ? 20 : 10; // Melee stronger
                const range = type === 'attack_melee' ? 2.0 : 30.0;

                logMessage(`${this.id} uses ${type} (Dmg: ${damage}, Rng: ${range})`, 'combat');
                logEvent('attack_performed', { attackerId: this.id, attackType: type, damage: damage, range: range });

                // Get current forward direction
                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);

                if (type === 'attack_melee') {
                    playSound('hit_melee');
                    // Check entities in a cone/box in front? Simpler: sphere check offset forward.
                    const attackPos = this.mesh.position.clone().add(forward.multiplyScalar(1.0)); // Check slightly in front

                    entities.forEach(entity => {
                        if (entity.id !== this.id && entity.rigidBody && entity.mesh.position.distanceTo(attackPos) < range) {
                             logMessage(`${this.id} hits ${entity.id} with melee!`, 'combat');
                             // Damage dealt event logged within takeDamage
                             entity.takeDamage(damage, this.id);
                        }
                    });
                } else { // attack_range
                    playSound('hit_range');
                    // Create a projectile
                    const projectileGeo = new THREE.SphereGeometry(0.1, 8, 8);
                    const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const projectileMesh = new THREE.Mesh(projectileGeo, projectileMat);

                    const startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)); // Start near 'head'
                    projectileMesh.position.copy(startPos).add(forward.multiplyScalar(0.6)); // Start slightly ahead

                    const projectileBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                        .setTranslation(projectileMesh.position.x, projectileMesh.position.y, projectileMesh.position.z)
                        .setGravityScale(0.2) // Less affected by gravity
                        .setCcdEnabled(true); // Continuous Collision Detection for fast objects
                    const projectileBody = physicsWorld.createRigidBody(projectileBodyDesc);

                    const projectileColliderDesc = RAPIER.ColliderDesc.ball(0.1)
                        .setSensor(true) // Sensor detects collision but doesn't cause physical reaction
                        .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                    const projectileCollider = physicsWorld.createCollider(projectileColliderDesc, projectileBody);
                    const projectileId = `proj_${generateUUID()}`;
                    projectileCollider.userData = { type: 'projectile', id: projectileId, damage: damage, ownerId: this.id, mesh: projectileMesh };

                    logEvent('projectile_fired', { ownerId: this.id, projectileId: projectileId, damage: damage, startPos: projectileMesh.position.toArray(), direction: forward.toArray() });

                    // Apply initial impulse
                    const speed = 30.0;
                    projectileBody.applyImpulse(forward.multiplyScalar(speed), true);

                    scene.add(projectileMesh);

                    // Self-destruct after time
                    setTimeout(() => {
                        if (projectileMesh.parent) scene.remove(projectileMesh);
                        // Check body exists before removing
                        if (physicsWorld.getRigidBody(projectileBody.handle)) {
                            logEvent('projectile_destroyed', { projectileId: projectileId, reason: 'timeout' });
                            physicsWorld.removeRigidBody(projectileBody);
                        }
                    }, 3000); // Projectile lasts 3 seconds
                }
            }

            takeDamage(amount, attackerId) {
                 const artifactKeys = Array.from(this.artifacts.keys());
                 let damageApplied = false;
                 if (artifactKeys.length > 0) {
                     const randomType = artifactKeys[Math.floor(Math.random() * artifactKeys.length)];
                     const artifact = this.artifacts.get(randomType);
                     const artifactId = artifact?.id;

                     if (artifactId) {
                        // Attempt to remove the artifact, passing the reason
                        const removedId = this.removeArtifact(randomType, `damage_from_${attackerId}`);
                        if (removedId) {
                            logMessage(`${this.id}'s ${randomType} artifact ${removedId} was destroyed by ${attackerId}!`, 'combat');
                            logEvent('artifact_destroyed_by_damage', { victimId: this.id, attackerId: attackerId, artifactId: removedId, abilityType: randomType });
                            destroyArtifact(removedId, `damage_from_${attackerId}`); // Pass reason
                            playSound('destroy');
                            damageApplied = true;
                        }
                     }
                 }

                 // If no artifact was destroyed (either none existed or removal failed), apply HP damage
                 if (!damageApplied) {
                     this.hp -= amount;
                     this.hp = Math.max(0, this.hp); // Ensure HP doesn't go below 0
                     logMessage(`${this.id} took ${amount} direct damage from ${attackerId}. HP: ${this.hp}`, 'combat');
                     logEvent('damage_taken', { victimId: this.id, attackerId: attackerId, amount: amount, hpRemaining: this.hp, type: artifactKeys.length > 0 ? 'direct_artifact_failed' : 'direct_no_artifacts' });
                     if (this.hp <= 0) {
                         this.die(attackerId);
                     }
                 }
            }

            die(killerId = 'unknown') {
                if (!entities.has(this.id)) return; // Already dead / removed

                logMessage(`${this.id} has been defeated by ${killerId}. Soul absorbed by the Abyss.`, 'game');
                logEvent('entity_death', { entityId: this.id, killerId: killerId, position: this.mesh.position.toArray() });
                playSound('destroy');

                // Drop all remaining artifacts
                const artifactTypes = Array.from(this.artifacts.keys());
                artifactTypes.forEach(type => {
                    const artifact = this.artifacts.get(type);
                    const artifactId = artifact?.id;
                    if (artifactId) {
                        const removedId = this.removeArtifact(type, 'death_drop'); // Logs removal event
                        if (removedId) {
                            logEvent('artifact_dropped_on_death', { ownerId: this.id, artifactId: removedId, abilityType: type });
                            // Don't destroy the artifact, let it fall to the ground
                            const artifactInstance = artifacts.get(removedId);
                            if (artifactInstance) {
                                artifactInstance.attachedTo = null;
                                // Position it where the entity died
                                artifactInstance.mesh.position.copy(this.mesh.position);
                                artifactInstance.mesh.position.y = 0.5; // Place on ground
                                // Add back to scene root if it was removed from entity mesh
                                if (!artifactInstance.mesh.parent) {
                                    scene.add(artifactInstance.mesh);
                                }
                            }
                        }
                    }
                });

                // Remove entity from game
                scene.remove(this.mesh);
                 if (this.rigidBody && physicsWorld.getRigidBody(this.rigidBody.handle)) {
                    physicsWorld.removeRigidBody(this.rigidBody);
                }
                entities.delete(this.id);

                if (this.isPlayer) {
                    logMessage("YOU DIED. The Abyss consumes your soul... for now.", 'error');
                    logEvent('player_death', { killerId: killerId });
                    if (isRecording) stopRecording(); // Stop recording on player death
                    setTimeout(() => window.location.reload(), 3000); // Simple reload
                } else {
                    // No extra drop chance needed, all artifacts are dropped now
                    if (llmReady) {
                        logMessage(`Soul ${this.soul} is now free in the Abyss.`, 'llm');
                        logEvent('soul_released', { entityId: this.id, soulId: this.soul });
                    }
                }
            }

             interact() {
                 if (!this.isPlayer) return;

                 const interactionRadius = 2.0;
                 let closestArtifact = null;
                 let minDistSq = interactionRadius * interactionRadius;
                 const playerPos = this.mesh.position;

                 artifacts.forEach(artifact => {
                     if (!artifact.attachedTo && artifact.mesh) {
                         const distSq = playerPos.distanceToSquared(artifact.mesh.position);
                         if (distSq < minDistSq) {
                             minDistSq = distSq;
                             closestArtifact = artifact;
                         }
                     }
                 });

                 if (closestArtifact) {
                     logMessage(`Player attempts to pick up ${closestArtifact.id} (${closestArtifact.abilityType})`, 'pickup');
                     logEvent('interaction_attempt', { entityId: this.id, targetArtifactId: closestArtifact.id, targetType: 'artifact' });
                     if (this.addArtifact(closestArtifact)) { // addArtifact logs its own success event
                         // Success handled in addArtifact
                     } else {
                         logMessage(`Could not assemble ${closestArtifact.id}.`, 'warning');
                         logEvent('interaction_failed', { entityId: this.id, targetArtifactId: closestArtifact.id, reason: 'assembly_failed' });
                     }
                 } else {
                     logMessage("Nothing nearby to interact with.", 'info');
                     logEvent('interaction_attempt', { entityId: this.id, targetArtifactId: null, targetType: null, reason: 'nothing_in_range' });
                 }
             }
        } // End Entity Class

        class Artifact {
            constructor(id, abilityType, position = { x: 0, y: 0.5, z: 0 }, level = 1) {
                this.id = id;
                this.abilityType = abilityType || getRandomAbilityType();
                this.level = level;
                this.creationTime = Date.now();
                this.attachedTo = null; // Entity ID if attached

                // Visual representation
                let geometry, material;
                const colorMap = {
                    'move': 0x0000ff, 'see': 0xffff00, 'attack_melee': 0xff0000,
                    'attack_range': 0xffa500, 'tool_creation_tool': 0x00ffff, 'default': 0xaaaaaa
                };
                const matParams = { color: colorMap[this.abilityType] || colorMap['default'] };
                if (this.abilityType === 'tool_creation_tool') {
                    matParams.emissive = 0x00aaaa;
                }
                material = new THREE.MeshStandardMaterial(matParams);

                switch (this.abilityType) {
                    case 'move': geometry = new THREE.ConeGeometry(0.2, 0.4, 4); break;
                    case 'see': geometry = new THREE.SphereGeometry(0.2, 8, 8); break;
                    case 'attack_melee': geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3); break;
                    case 'attack_range': geometry = new THREE.TorusGeometry(0.15, 0.05, 8, 16); break;
                    case 'tool_creation_tool': geometry = new THREE.IcosahedronGeometry(0.25); break;
                    default: geometry = new THREE.DodecahedronGeometry(0.2);
                }
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(position.x, position.y, position.z);
                this.mesh.userData = { artifactId: this.id, type: 'artifact' };
                scene.add(this.mesh);

                artifacts.set(this.id, this);
                logMessage(`Created Artifact ${this.id} (${this.abilityType}) at ${position.x.toFixed(1)}, ${position.z.toFixed(1)}`, 'game');
                logEvent('artifact_created', { artifactId: this.id, abilityType: this.abilityType, position: [position.x, position.y, position.z], level: level });
            }
        } // End Artifact Class

        function createArtifact(abilityType = null, position = null) {
            const id = `artifact_${artifactIdCounter++}`;
            if (!position) {
                const radius = Math.random() * (ARENA_RADIUS - 5) + 5;
                const angle = Math.random() * Math.PI * 2;
                position = { x: Math.cos(angle) * radius, y: 0.5, z: Math.sin(angle) * radius };
            }
            // Ensure position is valid
            position.y = position.y || 0.5;

            return new Artifact(id, abilityType, position);
        }

        function destroyArtifact(artifactId, reason = 'unknown') {
            const artifact = artifacts.get(artifactId);
            if (artifact) {
                logEvent('artifact_destroyed', { artifactId: artifact.id, abilityType: artifact.abilityType, reason: reason });
                if (artifact.mesh) {
                    if (artifact.mesh.parent) artifact.mesh.parent.remove(artifact.mesh);
                    // Dispose geometry and material to free GPU memory? Maybe overkill for jam.
                    // artifact.mesh.geometry.dispose();
                    // artifact.mesh.material.dispose();
                }
                artifacts.delete(artifactId);
                logMessage(`Destroyed Artifact ${artifactId} (Reason: ${reason})`, 'destroy');
            }
        }

         function getRandomAbilityType(allowToolCreation = false) {
             const types = ['move', 'see', 'attack_melee', 'attack_range'];
             // Slightly higher chance for tool creation for testing? No, keep it rare.
             if (allowToolCreation && Math.random() < 0.01) { // 1% chance if allowed
                return 'tool_creation_tool';
             }
             return types[Math.floor(Math.random() * types.length)];
         }

        // --- Physics ---
        async function initPhysics() {
            logMessage("Initializing Physics Engine (Rapier)...", 'system');
            await RAPIER.init();
            const gravity = { x: 0.0, y: -9.81, z: 0.0 };
            physicsWorld = new RAPIER.World(gravity);
            eventQueue = new RAPIER.EventQueue(true);
            logMessage("Physics Engine Ready.", 'system');
        }

        function setupArena() {
            // Ground
            const groundSize = ARENA_RADIUS * 2.5;
            const groundHeight = 0.1;
            const groundGeo = new THREE.CylinderGeometry(ARENA_RADIUS, ARENA_RADIUS, groundHeight, 64);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.2, roughness: 0.8 });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.position.y = -groundHeight / 2;
            scene.add(groundMesh);

            const groundBodyDesc = RAPIER.RigidBodyDesc.fixed();
            const groundColliderDesc = RAPIER.ColliderDesc.cylinder(groundHeight / 2, ARENA_RADIUS);
            const groundBody = physicsWorld.createRigidBody(groundBodyDesc);
            physicsWorld.createCollider(groundColliderDesc, groundBody.handle);

            // Visual Walls
            const wallHeight = ARENA_HEIGHT;
            const wallGeo = new THREE.CylinderGeometry(ARENA_RADIUS, ARENA_RADIUS, wallHeight, 64, 1, true); // Open ended
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x886666, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
            const wallMesh = new THREE.Mesh(wallGeo, wallMat);
            wallMesh.position.y = wallHeight / 2;
            scene.add(wallMesh);

            // Physics Walls (Slightly outside visual radius)
            const wallThickness = 1.0;
            const wallBodyDesc = RAPIER.RigidBodyDesc.fixed(); // Use a separate body for walls/ceiling
            const wallBody = physicsWorld.createRigidBody(wallBodyDesc);

            const numWallSegments = 32;
            const segmentAngle = (Math.PI * 2) / numWallSegments;
            const wallSegmentLength = ARENA_RADIUS * 2 * Math.tan(segmentAngle / 2); // Approximation
            const wallRadiusOffset = ARENA_RADIUS + wallThickness / 2;

            for (let i = 0; i < numWallSegments; i++) {
                const angle = i * segmentAngle;
                const x = Math.cos(angle + segmentAngle / 2) * wallRadiusOffset;
                const z = Math.sin(angle + segmentAngle / 2) * wallRadiusOffset;
                const wallSegmentColliderDesc = RAPIER.ColliderDesc.cuboid(wallThickness / 2, wallHeight / 2, wallSegmentLength / 2)
                    .setTranslation(x, wallHeight / 2, z)
                    .setRotation({ w: Math.cos(-angle/2), x: 0, y: Math.sin(-angle/2), z: 0 }); // Rotate segment
                physicsWorld.createCollider(wallSegmentColliderDesc, wallBody.handle);
            }


             // Physics Ceiling (Invisible)
             const ceilingColliderDesc = RAPIER.ColliderDesc.cuboid(ARENA_RADIUS * 1.1, 0.1, ARENA_RADIUS * 1.1) // Slightly larger than radius
                .setTranslation(0, ARENA_HEIGHT + 0.1, 0);
            physicsWorld.createCollider(ceilingColliderDesc, wallBody.handle); // Attach to the fixed wall body

            logMessage(`Arena created with radius ${ARENA_RADIUS}.`, 'game');
        }

         function handleCollisions() {
             eventQueue.drainCollisionEvents((handle1, handle2, started) => {
                 if (!started) return; // Only handle collision start events

                 const collider1 = physicsWorld.getCollider(handle1);
                 const collider2 = physicsWorld.getCollider(handle2);
                 // Check if colliders still exist (might be removed mid-frame)
                 if (!collider1 || !collider2) return;

                 const userData1 = collider1.userData;
                 const userData2 = collider2.userData;

                 // Simplify logging data
                 const logData1 = { handle: handle1, type: userData1?.type, id: userData1?.entityId || userData1?.artifactId || userData1?.id };
                 const logData2 = { handle: handle2, type: userData2?.type, id: userData2?.entityId || userData2?.artifactId || userData2?.id };
                 logEvent('collision_started', { collider1: logData1, collider2: logData2 });


                 // Projectile collision
                 let projectileData = null, otherData = null;
                 let projectileCollider = null, projectileBody = null;

                 if (userData1?.type === 'projectile') {
                     projectileData = userData1; otherData = userData2; projectileCollider = collider1;
                 } else if (userData2?.type === 'projectile') {
                     projectileData = userData2; otherData = userData1; projectileCollider = collider2;
                 }

                 if (projectileData && projectileCollider) {
                     projectileBody = projectileCollider.parent();
                     // Check if projectile body still exists
                     if (!projectileBody || !physicsWorld.getRigidBody(projectileBody.handle)) {
                         // Projectile might have been destroyed already (e.g., timeout)
                         return;
                     }

                     let targetEntity = null;
                     if (otherData?.type === 'entity' && otherData.entityId !== projectileData.ownerId) {
                         targetEntity = entities.get(otherData.entityId);
                     }

                     logEvent('projectile_collision', {
                         projectileId: projectileData.id,
                         ownerId: projectileData.ownerId,
                         targetType: otherData?.type,
                         targetId: otherData?.id || otherData?.entityId || otherData?.artifactId,
                         hitEntity: !!targetEntity
                     });

                     if (targetEntity) {
                         logMessage(`Projectile ${projectileData.id} from ${projectileData.ownerId} hit ${targetEntity.id}!`, 'combat');
                         targetEntity.takeDamage(projectileData.damage, projectileData.ownerId); // takeDamage logs the damage event
                     }

                     // Remove projectile on impact with anything other than another sensor/projectile?
                     if (otherData?.type !== 'projectile' && !collider1.isSensor() && !collider2.isSensor()) {
                         if (projectileData.mesh && projectileData.mesh.parent) scene.remove(projectileData.mesh);
                         // Check body exists before removing
                         if (physicsWorld.getRigidBody(projectileBody.handle)) {
                             logEvent('projectile_destroyed', { projectileId: projectileData.id, reason: 'impact' });
                             physicsWorld.removeRigidBody(projectileBody);
                         }
                     }
                 }
             });
         }

        // --- Controls ---
        function initControls() {
            logMessage("Initializing Controls...", 'system');
            // Keyboard
            window.addEventListener('keydown', (e) => {
                // Allow chat input without triggering game actions
                if (document.activeElement === chatInput) return;

                switch (e.code) {
                    case 'KeyW': case 'ArrowUp': inputState.moveForward = 1; break;
                    case 'KeyS': case 'ArrowDown': inputState.moveBackward = 1; break;
                    case 'KeyA': case 'ArrowLeft': inputState.moveLeft = 1; break;
                    case 'KeyD': case 'ArrowRight': inputState.moveRight = 1; break;
                    case 'KeyQ': inputState.rotateLeft = 1; break;
                    case 'KeyE': inputState.rotateRight = 1; break;
                    case 'KeyF': case 'Space': inputState.actionInteract = true; break; // Interact
                    case 'Digit1': case 'KeyJ': inputState.actionMelee = true; break; // Melee Attack
                    case 'Digit2': case 'KeyK': inputState.actionRange = true; break; // Range Attack
                }
            });
            window.addEventListener('keyup', (e) => {
                 if (document.activeElement === chatInput) return;

                switch (e.code) {
                    case 'KeyW': case 'ArrowUp': inputState.moveForward = 0; break;
                    case 'KeyS': case 'ArrowDown': inputState.moveBackward = 0; break;
                    case 'KeyA': case 'ArrowLeft': inputState.moveLeft = 0; break;
                    case 'KeyD': case 'ArrowRight': inputState.moveRight = 0; break;
                    case 'KeyQ': inputState.rotateLeft = 0; break;
                    case 'KeyE': inputState.rotateRight = 0; break;
                    // Action keys are handled differently (momentary press)
                }
            });

             // Touch Controls (NippleJS)
             try {
                 const joystickZoneLeft = document.getElementById('joystick-left');
                 const joystickZoneRight = document.getElementById('joystick-right');

                 if (joystickZoneLeft && joystickZoneRight) {
                     const commonOptions = {
                         mode: 'static',
                         position: { left: '50%', top: '50%' },
                         color: 'rgba(255,255,255,0.5)',
                         size: 80
                     };
                     moveJoystick = nipplejs.create({...commonOptions, zone: joystickZoneLeft });
                     lookJoystick = nipplejs.create({...commonOptions, zone: joystickZoneRight });

                     moveJoystick.on('move', (evt, data) => {
                         if (data.vector) {
                             inputState.touchMove.x = data.vector.x;
                             inputState.touchMove.y = data.vector.y;
                         }
                     }).on('end', () => {
                         inputState.touchMove.x = 0;
                         inputState.touchMove.y = 0;
                     });

                     lookJoystick.on('move', (evt, data) => {
                         if (data.vector) {
                             inputState.touchLook.x = data.vector.x;
                             inputState.touchLook.y = data.vector.y; // Use for vertical look later?
                         }
                     }).on('end', () => {
                         inputState.touchLook.x = 0;
                         inputState.touchLook.y = 0;
                     });

                     logMessage("Touch controls initialized.", 'system');
                 } else {
                     logMessage("Joystick zones not found.", 'warning');
                 }

                 // Touch Buttons - Use pointer events for better multi-touch handling
                 const setupButton = (button, action) => {
                     button.addEventListener('pointerdown', (e) => {
                         e.preventDefault(); // Prevent default touch actions
                         if (!button.disabled) {
                             inputState[action] = true;
                             playSound(); // Basic click sound
                             button.style.background = 'rgba(120, 120, 120, 0.8)'; // Active feedback
                         }
                     });
                     // Release state on pointerup or pointerleave/cancel
                     const releaseAction = (e) => {
                         e.preventDefault();
                         inputState[action] = false;
                         button.style.background = 'rgba(80, 80, 80, 0.7)'; // Reset background
                     };
                     button.addEventListener('pointerup', releaseAction);
                     button.addEventListener('pointerleave', releaseAction);
                     button.addEventListener('pointercancel', releaseAction);
                 };

                 setupButton(attackMeleeButton, 'actionMelee');
                 setupButton(attackRangeButton, 'actionRange');
                 setupButton(interactButton, 'actionInteract');


             } catch (err) {
                 logMessage(`Failed to initialize NippleJS: ${err}`, 'error');
             }


            // Gamepad API
            window.addEventListener("gamepadconnected", (event) => {
                logMessage(`Gamepad connected: ${event.gamepad.id}`, 'system');
                inputState.gamepadConnected = true;
            });
            window.addEventListener("gamepaddisconnected", (event) => {
                logMessage(`Gamepad disconnected: ${event.gamepad.id}`, 'system');
                inputState.gamepadConnected = false;
            });

            // Resume AudioContext on first interaction
            const resumeAudio = () => {
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                window.removeEventListener('pointerdown', resumeAudio);
                 window.removeEventListener('keydown', resumeAudio);
            };
            window.addEventListener('pointerdown', resumeAudio, { once: true });
             window.addEventListener('keydown', resumeAudio, { once: true });


            logMessage("Controls Initialized.", 'system');
        }

        function processInput(deltaTime) {
            // This function now ONLY reads input devices and sets the inputState object.
            // It does NOT apply physics directly.
            if (!player || !player.rigidBody || demoModeActive) return; // Don't process user input in demo mode

            // --- Reset momentary actions ---
            // These are set by keydown/pointerdown and should only trigger once.
            // The application logic in animate() will check these flags.
            // We reset them here unless the key/button is still held down (handled by continuous flags like moveForward).
            // For simplicity with multiple input types, let's make actions momentary unless held.
            // Flags like actionMelee, actionRange, actionInteract are set true on press,
            // and need to be reset *after* being checked in the physics application step.
            // Let's handle the reset in the physics application step instead.

            // --- Gamepad Input ---
            if (inputState.gamepadConnected) {
                const gamepads = navigator.getGamepads();
                for (const gp of gamepads) {
                    if (!gp) continue;

                    // Axes (Left Stick for Move, Right Stick for Look)
                    const leftStickX = gp.axes[0];
                    const leftStickY = gp.axes[1];
                    const rightStickX = gp.axes[2];

                    // Deadzone
                    const deadzone = 0.15;
                    inputState.moveForward = (leftStickY < -deadzone) ? -leftStickY : 0;
                    inputState.moveBackward = (leftStickY > deadzone) ? leftStickY : 0;
                    inputState.moveLeft = (leftStickX < -deadzone) ? -leftStickX : 0;
                    inputState.moveRight = (leftStickX > deadzone) ? leftStickX : 0;
                    inputState.rotateLeft = (rightStickX < -deadzone) ? -rightStickX : 0;
                    inputState.rotateRight = (rightStickX > deadzone) ? rightStickX : 0;


                    // Buttons (Standard Layout Mapping)
                    // We check 'pressed' state. The application logic will handle momentary actions.
                    if (gp.buttons[0]?.pressed) inputState.actionInteract = true; else inputState.actionInteract = false; // A / Cross
                    if (gp.buttons[2]?.pressed) inputState.actionMelee = true; else inputState.actionMelee = false; // X / Square
                    if (gp.buttons[3]?.pressed) inputState.actionRange = true; else inputState.actionRange = false; // Y / Triangle
                    // Add more buttons if needed (e.g., bumpers for rotation?)
                    // if (gp.buttons[4]?.pressed) inputState.rotateLeft = 1; // L1
                    // if (gp.buttons[5]?.pressed) inputState.rotateRight = 1; // R1

                    break; // Use first connected gamepad
                }
            }

            // --- Keyboard Input (Overrides Gamepad movement/rotation if pressed) ---
            // Continuous movement/rotation flags are set by keydown/keyup listeners directly.
            // Momentary action flags (interact, melee, range) are set by keydown listener.
            // They need to be reset after use in the physics application step.

            // --- Touch Input (Overrides Keyboard/Gamepad if active) ---
             if (Math.abs(inputState.touchMove.y) > 0.1 || Math.abs(inputState.touchMove.x) > 0.1) {
                 // Touch joystick provides normalized vector (-1 to 1)
                 inputState.moveForward = Math.max(0, -inputState.touchMove.y);
                 inputState.moveBackward = Math.max(0, inputState.touchMove.y);
                 inputState.moveLeft = Math.max(0, -inputState.touchMove.x);
                 inputState.moveRight = Math.max(0, inputState.touchMove.x);
             }
              if (Math.abs(inputState.touchLook.x) > 0.1) {
                  inputState.rotateLeft = Math.max(0, -inputState.touchLook.x);
                  inputState.rotateRight = Math.max(0, inputState.touchLook.x);
              }
             // Touch action buttons set inputState flags directly via pointer events.
        }

        // --- Demo Mode Logic ---
        function findNearestUnattachedArtifact(position, maxDist = ARENA_RADIUS * 2, excludeType = null) {
            let closestArtifact = null;
            let minDistSq = maxDist * maxDist;

            artifacts.forEach(artifact => {
                if (!artifact.attachedTo && artifact.mesh && artifact.abilityType !== excludeType) {
                    const distSq = position.distanceToSquared(artifact.mesh.position);
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closestArtifact = artifact;
                    }
                }
            });
            return closestArtifact;
        }

        function findNearestEnemy(position, maxDist = 30) { // Increased default range slightly
            let closestEnemy = null;
            let minDistSq = maxDist * maxDist;

            entities.forEach(entity => {
                // Check if entity exists, is not player, and has a valid physics body
                if (!entity.isPlayer && entity.rigidBody && physicsWorld.getRigidBody(entity.rigidBody.handle)) {
                    const distSq = position.distanceToSquared(entity.mesh.position);
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        closestEnemy = entity;
                    }
                }
            });
            return closestEnemy;
        }

        function findGoalArtifact(position) {
             let goalArtifact = null;
             artifacts.forEach(artifact => {
                 if (!artifact.attachedTo && artifact.abilityType === 'tool_creation_tool') {
                     goalArtifact = artifact;
                 }
             });
             return goalArtifact;
        }

        function processDemoInput(deltaTime) {
            if (!player || !player.rigidBody || !demoModeActive) return;

            // Reset input state at the beginning of each frame
            Object.keys(inputState).forEach(key => {
                if (typeof inputState[key] === 'number') inputState[key] = 0;
                if (typeof inputState[key] === 'boolean') inputState[key] = false;
                if (typeof inputState[key] === 'object' && inputState[key] !== null && key !== 'touchMove' && key !== 'touchLook') { // Keep touch objects but zero them
                    inputState[key].x = 0; inputState[key].y = 0;
                }
            });
            inputState.touchMove.x = 0; inputState.touchMove.y = 0;
            inputState.touchLook.x = 0; inputState.touchLook.y = 0;


            const playerPos = player.mesh.position;
            const playerRot = player.mesh.quaternion;
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(playerRot); // Player's forward Z+

            demoStateTimer += deltaTime;

            // --- State Decision Logic ---
            if (demoStateTimer > DEMO_STATE_TIMEOUT || demoState === 'IDLE' ||
               (demoState === 'SEEK_ENEMY' && (!demoTargetEntity || !entities.has(demoTargetEntity.id))) || // Target lost
               ((demoState === 'SEEK_ARTIFACT' || demoState === 'SEEK_GOAL') && (!demoTargetArtifact || !artifacts.has(demoTargetArtifact.id) || demoTargetArtifact.attachedTo)) // Target lost or picked up
               )
            {
                demoStateTimer = 0;
                demoTargetArtifact = null;
                demoTargetEntity = null;

                const nearestEnemy = findNearestEnemy(playerPos);
                // Don't seek tool if already have it
                const goalArtifact = player.hasAbility('tool_creation_tool') ? null : findGoalArtifact(playerPos);
                // Prioritize needed artifacts if missing basic ones
                const needsMove = !player.hasAbility('move');
                const needsSee = !player.hasAbility('see'); // Or maybe prioritize combat artifacts?
                const needsCombat = !player.hasAbility('attack_melee') && !player.hasAbility('attack_range');

                let preferredArtifact = null;
                if(needsMove) preferredArtifact = findNearestUnattachedArtifact(playerPos, ARENA_RADIUS * 2, 'move');
                if(!preferredArtifact && needsSee) preferredArtifact = findNearestUnattachedArtifact(playerPos, ARENA_RADIUS * 2, 'see');
                if(!preferredArtifact && needsCombat) {
                    preferredArtifact = findNearestUnattachedArtifact(playerPos, ARENA_RADIUS * 2, 'attack_melee') || findNearestUnattachedArtifact(playerPos, ARENA_RADIUS * 2, 'attack_range');
                }
                // If basic needs met, find any useful artifact (excluding goal if already seeking it)
                if (!preferredArtifact && !goalArtifact) {
                    preferredArtifact = findNearestUnattachedArtifact(playerPos, ARENA_RADIUS * 2, 'tool_creation_tool');
                }


                // Priority: Attack nearby enemies > Get Goal > Get Needed Artifact > Get Any Artifact > Wander
                if (nearestEnemy && (player.hasAbility('attack_melee') || player.hasAbility('attack_range'))) {
                    demoState = 'SEEK_ENEMY';
                    demoTargetEntity = nearestEnemy;
                    logMessage(`Demo: Found enemy ${nearestEnemy.id}. State -> SEEK_ENEMY`, 'demo');
                } else if (goalArtifact) {
                    demoState = 'SEEK_GOAL';
                    demoTargetArtifact = goalArtifact;
                     logMessage(`Demo: Found goal artifact ${goalArtifact.id}. State -> SEEK_GOAL`, 'demo');
                } else if (preferredArtifact) {
                    demoState = 'SEEK_ARTIFACT';
                    demoTargetArtifact = preferredArtifact;
                    logMessage(`Demo: Found artifact ${preferredArtifact.id} (${preferredArtifact.abilityType}). State -> SEEK_ARTIFACT`, 'demo');
                } else {
                    demoState = 'WANDER';
                    logMessage(`Demo: No targets found. State -> WANDER`, 'demo');
                }
            }

            // --- State Execution Logic ---
            let targetPosition = null;
            let targetDistance = Infinity;

            // Determine target position based on state
            if (demoState === 'SEEK_ENEMY' && demoTargetEntity && entities.has(demoTargetEntity.id)) {
                targetPosition = demoTargetEntity.mesh.position;
            } else if ((demoState === 'SEEK_ARTIFACT' || demoState === 'SEEK_GOAL') && demoTargetArtifact && artifacts.has(demoTargetArtifact.id) && !demoTargetArtifact.attachedTo) {
                targetPosition = demoTargetArtifact.mesh.position;
            } else if (demoState === 'WANDER') {
                if (!player.wanderTarget || player.mesh.position.distanceTo(player.wanderTarget) < 3) {
                     // Pick new wander target
                     const wanderAngle = Math.random() * Math.PI * 2;
                     const wanderDist = 10 + Math.random() * 15;
                     player.wanderTarget = new THREE.Vector3(
                         playerPos.x + Math.cos(wanderAngle) * wanderDist,
                         playerPos.y,
                         playerPos.z + Math.sin(wanderAngle) * wanderDist
                     );
                     // Clamp wander target
                     const distFromCenter = Math.sqrt(player.wanderTarget.x**2 + player.wanderTarget.z**2);
                     if (distFromCenter > ARENA_RADIUS - 1) {
                         player.wanderTarget.x = (player.wanderTarget.x / distFromCenter) * (ARENA_RADIUS - 1);
                         player.wanderTarget.z = (player.wanderTarget.z / distFromCenter) * (ARENA_RADIUS - 1);
                     }
                     logMessage(`Demo: Wandering towards ${player.wanderTarget.x.toFixed(1)}, ${player.wanderTarget.z.toFixed(1)}`, 'demo');
                }
                targetPosition = player.wanderTarget;
            } else {
                // Invalid state or target lost, reset
                demoState = 'IDLE';
                demoStateTimer = DEMO_STATE_TIMEOUT; // Force state reconsideration next frame
                if (demoState !== 'IDLE') logMessage(`Demo: Target lost or invalid state (${demoState}). Resetting.`, 'demo'); // Log only if state wasn't already IDLE
            }

            // --- Action Execution based on Target ---
            if (targetPosition) {
                targetDistance = playerPos.distanceTo(targetPosition);
                const directionToTarget = new THREE.Vector3().subVectors(targetPosition, playerPos);
                directionToTarget.y = 0; // Ignore vertical difference for navigation
                if (directionToTarget.lengthSq() < 0.01) { // Already at target horizontally
                    directionToTarget.set(0,0,0);
                } else {
                    directionToTarget.normalize();
                }


                // --- Rotation ---
                if (directionToTarget.lengthSq() > 0) { // Only rotate if there's a direction
                    // Calculate angle difference between current forward and target direction
                    const angleToTarget = Math.atan2(directionToTarget.x, directionToTarget.z);
                    const currentAngle = Math.atan2(forward.x, forward.z);
                    let angleDiff = angleToTarget - currentAngle;
                    while (angleDiff <= -Math.PI) angleDiff += 2 * Math.PI;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                    // Apply rotation input (proportional?)
                    const rotationThreshold = 0.1; // Radians
                    const rotationSpeedFactor = Math.min(1, Math.abs(angleDiff) / (Math.PI / 4)); // Rotate faster for larger angles
                    if (angleDiff > rotationThreshold) {
                        inputState.rotateLeft = rotationSpeedFactor;
                    } else if (angleDiff < -rotationThreshold) {
                        inputState.rotateRight = rotationSpeedFactor;
                    }
                }

                // --- Movement ---
                const facingThreshold = Math.PI / 3; // 60 degrees
                const angleDiffRad = Math.abs(Math.atan2(forward.x, forward.z) - Math.atan2(directionToTarget.x, directionToTarget.z));
                const isFacingTarget = directionToTarget.lengthSq() === 0 || (angleDiffRad <= facingThreshold || angleDiffRad >= (2*Math.PI - facingThreshold));

                if (isFacingTarget && targetDistance > 1.5) { // Don't move if very close or not facing target
                    inputState.moveForward = 1;
                }

                // --- Interaction / Attack ---
                if (demoState === 'SEEK_ARTIFACT' || demoState === 'SEEK_GOAL') {
                    if (targetDistance < 1.8) { // Interaction range
                        inputState.actionInteract = true; // Set flag for physics step
                        logMessage(`Demo: Attempting to interact with ${demoTargetArtifact?.id}`, 'demo');
                        // Force state reconsideration after interaction attempt
                        demoState = 'IDLE';
                        demoStateTimer = DEMO_STATE_TIMEOUT;
                    }
                } else if (demoState === 'SEEK_ENEMY') {
                    const meleeRange = 2.0;
                    const preferredRangeMin = 5.0; // Try to stay outside this for ranged
                    const preferredRangeMax = 15.0; // Try to stay inside this for ranged

                    if (player.hasAbility('attack_melee') && targetDistance < meleeRange) {
                        inputState.actionMelee = true; // Set flag
                         logMessage(`Demo: Attempting melee attack on ${demoTargetEntity?.id}`, 'demo');
                    } else if (player.hasAbility('attack_range') && targetDistance < 20.0) { // Max range attack check
                         inputState.actionRange = true; // Set flag
                         logMessage(`Demo: Attempting range attack on ${demoTargetEntity?.id}`, 'demo');
                         // Strafing / Distance keeping for ranged? Maybe too complex for demo.
                         // Simple version: back up if too close, move forward if too far & facing
                         if (isFacingTarget) {
                             if (targetDistance < preferredRangeMin) {
                                 inputState.moveForward = 0;
                                 inputState.moveBackward = 0.5; // Back up
                             } else if (targetDistance > preferredRangeMax) {
                                 inputState.moveForward = 1; // Move closer
                                 inputState.moveBackward = 0;
                             } else {
                                 // In preferred range, maybe strafe slightly?
                                 if(Math.random() < 0.1) inputState.moveLeft = 0.5;
                                 else if(Math.random() < 0.1) inputState.moveRight = 0.5;
                                 else inputState.moveForward = 0; // Stop moving forward/back
                             }
                         }
                    }
                    // Check if enemy is defeated is handled in state transition logic
                }
            }

            // The inputState is now set, physics application happens in animate()
        }


        // --- Recording Logic ---
        function startRecording() {
            if (isRecording) return;
            isRecording = true;
            recordedFrames = [];
            recordedEvents = [];
            frameCounter = 0;
            startRecordingButton.disabled = true;
            stopRecordingButton.disabled = false;
            recordingStatusDiv.textContent = 'Rec: ON';
            logMessage("Started debug recording.", 'system');
            logEvent('recording_started', {});
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            startRecordingButton.disabled = false;
            stopRecordingButton.disabled = true;
            recordingStatusDiv.textContent = 'Rec: OFF';
            logMessage(`Stopped debug recording. Captured ${recordedFrames.length} frames and ${recordedEvents.length} events.`, 'system');
            logEvent('recording_stopped', { frameCount: frameCounter, eventCount: recordedEvents.length });
            saveRecordingData();
        }

        function logFrameData(deltaTime) { // Pass deltaTime
            if (!isRecording) return;

            const frameData = {
                frame: frameCounter,
                timestamp: Date.now(),
                deltaTime: deltaTime, // Log delta time for this frame
                demo: {
                    active: demoModeActive,
                    state: demoState,
                    targetEntityId: demoTargetEntity?.id || null,
                    targetArtifactId: demoTargetArtifact?.id || null,
                },
                player: null,
                entities: [], // Log nearby entities
                artifacts: [] // Log nearby artifacts
            };

            // Log Player State
            if (player && player.rigidBody && physicsWorld.getRigidBody(player.rigidBody.handle)) {
                const pos = player.mesh.position;
                const rot = player.mesh.quaternion;
                // Capture input state *before* it's potentially reset for the next frame
                const currentInputState = { ...inputState };
                frameData.player = {
                    id: player.id,
                    position: [pos.x, pos.y, pos.z],
                    rotation: [rot.x, rot.y, rot.z, rot.w],
                    hp: player.hp,
                    artifacts: Array.from(player.artifacts.keys()),
                    appliedInput: currentInputState // Log the input state used this frame
                };

                 // Log nearby entities/artifacts based on player position
                 const logRadiusSq = 25 * 25;

                 entities.forEach(entity => {
                     if (entity.id !== player.id && entity.rigidBody && physicsWorld.getRigidBody(entity.rigidBody.handle) && entity.mesh.position.distanceToSquared(player.mesh.position) < logRadiusSq) {
                         const ePos = entity.mesh.position;
                         const eRot = entity.mesh.quaternion;
                         frameData.entities.push({
                             id: entity.id,
                             position: [ePos.x, ePos.y, ePos.z],
                             rotation: [eRot.x, eRot.y, eRot.z, eRot.w],
                             hp: entity.hp,
                             artifacts: Array.from(entity.artifacts.keys())
                         });
                     }
                 });

                 artifacts.forEach(artifact => {
                     if (artifact.mesh && artifact.mesh.position.distanceToSquared(player.mesh.position) < logRadiusSq) {
                          const aPos = artifact.mesh.position;
                          frameData.artifacts.push({
                              id: artifact.id,
                              abilityType: artifact.abilityType,
                              position: [aPos.x, aPos.y, aPos.z],
                              attachedTo: artifact.attachedTo,
                              creationTime: artifact.creationTime
                          });
                     }
                 });

            } else {
                 frameData.player = { id: player?.id || 'player_invalid', position: [0,0,0], rotation: [0,0,0,1], hp: 0, artifacts: [], appliedInput: {} };
            }

            recordedFrames.push(frameData);
        }

        function saveRecordingData() {
            const recording = {
                version: 2, // Increment version if format changes
                startTime: recordedFrames.length > 0 ? recordedFrames[0].timestamp : Date.now(),
                endTime: Date.now(),
                totalFrames: frameCounter,
                arenaRadius: ARENA_RADIUS,
                initialEntities: [], // Could log initial setup if needed
                initialArtifacts: [], // Could log initial setup if needed
                frames: recordedFrames,
                events: recordedEvents
            };

            try {
                const dataStr = JSON.stringify(recording); // Use compact format for potentially large files
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);

                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                downloadLink.download = `abyss_arena_debug_${timestamp}.json`;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(url); // Clean up object URL

                logMessage(`Debug data saved as ${downloadLink.download}`, 'system');

            } catch (error) {
                 logMessage(`Error saving recording data: ${error}`, 'error');
                 console.error("Failed to stringify or save recording:", error);
                 // Maybe offer to copy to clipboard as fallback?
                 // navigator.clipboard.writeText(JSON.stringify(recording)).then(...)
            }
        }


        // --- LLM Integration ---
        function updateLLMControls() {
            const selectedEngine = llmEngineSelect.value;
            webllmOptionsDiv.style.display = selectedEngine === 'webllm' ? 'block' : 'none';
            llmjsOptionsDiv.style.display = selectedEngine === 'llmjs' ? 'block' : 'none';

            llmStatusDiv.textContent = `Status: ${llmLoading ? 'Loading...' : (llmReady ? `Ready (${llmType} - ${llmModelId})` : 'Not Loaded')}`;
            llmChatDiv.style.display = llmReady ? 'flex' : 'none';
            loadLlmButton.disabled = llmLoading;
        }

        async function loadLLM() {
            const selectedEngine = llmEngineSelect.value;
            if (selectedEngine === 'none') {
                unloadLLM();
                return;
            }
            if (llmLoading) {
                logMessage("LLM is already loading.", 'warning');
                return;
            }

            unloadLLM();
            llmLoading = true;
            llmType = selectedEngine;
            llmModelId = '';
            updateLLMControls();
            logMessage(`Loading LLM Engine: ${llmType}...`, 'llm');

            try {
                if (llmType === 'webllm') {
                    llmModelId = webllmModelSelect.value;
                    logMessage(`Loading WebLLM model: ${llmModelId}`, 'llm');
                    llmStatusDiv.textContent = 'Status: Initializing WebLLM Engine...';
                    const engine = await webllm.CreateMLCEngine(
                        llmModelId,
                        {
                            initProgressCallback: (report) => {
                                const progress = report.progress ? (report.progress * 100).toFixed(2) : 0;
                                llmStatusDiv.textContent = `Status: Loading ${llmModelId} - ${report.text} (${progress}%)`;
                                console.log(report);
                            }
                        }
                    );
                    llmEngine = engine;
                    llmReady = true;
                    logMessage("WebLLM Engine Ready.", 'llm');
                } else if (llmType === 'llmjs') {
                    llmModelId = llmjsModelSelect.options[llmjsModelSelect.selectedIndex].text;
                    const modelUrl = llmjsModelSelect.value;
                    logMessage(`Loading llm.js model: ${llmModelId} from ${modelUrl}`, 'llm');
                    llmStatusDiv.textContent = `Status: Downloading ${llmModelId}...`;

                    const { LLM } = await import('./llm.js/llm.js'); // Ensure path is correct

                    llmJsInstance = new LLM(
                        'GGUF_CPU', modelUrl,
                        () => { // on_loaded
                            logMessage("llm.js Model Loaded.", 'llm');
                            llmReady = true;
                            llmLoading = false; // Set loading false here
                            updateLLMControls();
                        },
                        (text) => { /* write_result - handled in run */ },
                        () => { /* run_complete - handled in run */ },
                         (error) => { // on_error
                            logMessage(`llm.js Error: ${error}`, 'error');
                            unloadLLM();
                         }
                    );
                    llmStatusDiv.textContent = `Status: Loading ${llmModelId} into llm.js worker...`;
                    llmJsInstance.load_worker();
                    // Readiness is handled by the on_loaded callback.
                } else {
                     throw new Error("Invalid or unimplemented LLM engine selected");
                }

            } catch (error) {
                logMessage(`Failed to load LLM: ${error}`, 'error');
                unloadLLM(); // Ensure cleanup on error
            } finally {
                // Set loading false only if not handled by async callback (like llm.js)
                 if (llmType !== 'llmjs') {
                    llmLoading = false;
                 }
                updateLLMControls(); // Update UI regardless of success/failure
            }
        }

        function unloadLLM() {
            if (llmEngine && llmType === 'webllm') {
                llmEngine.unload().catch(e => console.warn("Error unloading WebLLM:", e));
            }
            if (llmJsInstance && llmType === 'llmjs') {
                 // llm.js might need termination? Check its docs. Assume simple nullification for now.
                 llmJsInstance = null;
            }
            llmEngine = null;
            llmReady = false;
            llmLoading = false;
            llmType = 'none';
            llmModelId = '';
            chatHistory = [];
            availableLLMTools = { ...getBaseLLMTools() };
            logMessage("LLM Unloaded.", 'llm');
            updateLLMControls();
        }

        function getBaseLLMTools() {
             return {
                 'tool_creation_tool': {
                     description: "Creates a new tool (artifact ability) for the Abyss LLM. Takes a 'name' for the tool and a 'description' of what the tool should do as a javascript function. The function should accept a single object argument containing named parameters.",
                     parameters: {
                         type: "object",
                         properties: {
                             name: { type: "string", description: "The name of the new tool/function to create (use snake_case)." },
                             description: { type: "string", description: "A detailed description of what the new tool's javascript function should accomplish, including the parameters it needs." },
                         },
                         required: ["name", "description"]
                     },
                     function: async (args) => {
                         logMessage(`Executing tool_creation_tool: Name='${args.name}', Desc='${args.description}'`, 'llm');
                         logEvent('llm_tool_executed', { toolName: 'tool_creation_tool', args: args });
                         playSound('tool_create');
                         if (!args.name || !args.description) {
                             logEvent('llm_tool_failed', { toolName: 'tool_creation_tool', args: args, error: 'Missing name or description' });
                             return "Error: Missing 'name' or 'description' for tool_creation_tool.";
                         }
                         if (!/^[a-z_]+$/.test(args.name)) {
                              logEvent('llm_tool_failed', { toolName: 'tool_creation_tool', args: args, error: 'Invalid name format' });
                              return "Error: Tool name must be snake_case (lowercase letters and underscores only).";
                         }
                         if (availableLLMTools[args.name]) {
                              logEvent('llm_tool_failed', { toolName: 'tool_creation_tool', args: args, error: 'Tool already exists' });
                             return `Error: A tool named '${args.name}' already exists.`;
                         }

                         const creationPrompt = `Generate the JavaScript code for the *body* of a new tool function named '${args.name}'.
The function will receive a single argument named 'params' which is a JavaScript object containing the parameters.
The tool should do the following: ${args.description}.
Focus on game interaction if applicable (e.g., accessing 'player', 'entities', 'artifacts', 'createArtifact', 'logMessage', 'logEvent'). Be careful with direct manipulation.
Output *only* the raw JavaScript code for the function body inside a \`\`\`javascript block. Do not include 'function(...) {' or the closing '}'.
Example for 'adds two numbers x and y':
\`\`\`javascript
if (typeof params.x !== 'number' || typeof params.y !== 'number') { return 'Error: x and y must be numbers.'; }
const sum = params.x + params.y;
logEvent('tool_add_executed', { x: params.x, y: params.y, result: sum }); // Example logging within tool
return \`Sum is: \${sum}\`; // Return a string result for the chat
\`\`\`
Now, generate the code for '${args.name}':`;

                         try {
                             // Use a separate history for internal calls to avoid polluting user chat
                             const internalHistory = [{ role: 'user', content: creationPrompt }];
                             const codeResponse = await sendAbyssMessage(internalHistory, true);

                             const codeMatch = codeResponse.match(/```javascript\s*([\s\S]*?)\s*```/);
                             if (!codeMatch || !codeMatch[1]) {
                                 logMessage("LLM failed to generate valid JS code block for the new tool.", 'error');
                                 logEvent('llm_tool_failed', { toolName: 'tool_creation_tool', args: args, error: 'LLM failed to generate JS code block' });
                                 return "Error: Could not generate JavaScript code block for the new tool.";
                             }
                             const functionBody = codeMatch[1].trim();

                             // Create the new function (potentially unsafe, use with caution!)
                             // Consider sandboxing if this were production.
                             const newToolFunction = new Function('params', `
                                 // Access global scope (player, entities, etc.) - Be careful!
                                 const player = window.player; // Assuming player is global
                                 const entities = window.entities;
                                 const artifacts = window.artifacts;
                                 const createArtifact = window.createArtifact;
                                 const logMessage = window.logMessage;
                                 const logEvent = window.logEvent;
                                 const THREE = window.THREE; // Make THREE available if needed
                                 const RAPIER = window.RAPIER; // Make RAPIER available if needed

                                 try {
                                     ${functionBody}
                                 } catch (e) {
                                     logMessage('Error executing tool "${args.name}": ' + e.message, 'error');
                                     logEvent('llm_tool_execution_error', { toolName: "${args.name}", error: e.message, stack: e.stack });
                                     return 'Error during tool execution: ' + e.message;
                                 }
                             `);

                             const paramPrompt = `Based on the description "${args.description}", define the JSON schema for the 'params' object that the new tool '${args.name}' expects.
Output *only* the JSON schema object inside a \`\`\`json block.
Example for 'adds two numbers x and y':
\`\`\`json
{
  "type": "object",
  "properties": {
    "x": { "type": "number", "description": "First number" },
    "y": { "type": "number", "description": "Second number" }
  },
  "required": ["x", "y"]
}
\`\`\`
Now, generate the JSON schema for '${args.name}':`;
                             internalHistory.push({ role: 'assistant', content: codeResponse }); // Add previous response
                             internalHistory.push({ role: 'user', content: paramPrompt });
                             const paramResponse = await sendAbyssMessage(internalHistory, true);
                             const paramMatch = paramResponse.match(/```json\s*([\s\S]*?)\s*```/);
                             let newToolParamsSchema = { type: "object", properties: {} };
                             if (paramMatch && paramMatch[1]) {
                                 try {
                                     newToolParamsSchema = JSON.parse(paramMatch[1].trim());
                                 } catch (e) {
                                     logMessage(`Failed to parse JSON schema for new tool ${args.name}: ${e}. Using default.`, 'error');
                                     logEvent('llm_tool_warning', { toolName: args.name, warning: 'Failed to parse parameter schema', error: e.message });
                                 }
                             } else {
                                 logMessage(`LLM did not provide a valid parameter schema for ${args.name}. Using default.`, 'warning');
                                 logEvent('llm_tool_warning', { toolName: args.name, warning: 'No parameter schema provided' });
                             }

                             // Add the new tool
                             availableLLMTools[args.name] = {
                                 description: args.description,
                                 parameters: newToolParamsSchema,
                                 function: newToolFunction // The actual JS function
                             };

                             logMessage(`Successfully created and added new tool: ${args.name}`, 'llm');
                             logEvent('llm_tool_created', { toolName: args.name, description: args.description, parameters: newToolParamsSchema });

                             // Maybe create a corresponding artifact? Not directly linked for now.
                             // createArtifact(args.name, ...);

                             return `New tool '${args.name}' created successfully and is now available for use.`;

                         } catch (error) {
                             logMessage(`Error during tool creation process: ${error}`, 'error');
                             logEvent('llm_tool_failed', { toolName: 'tool_creation_tool', args: args, error: `Tool creation process error: ${error.message}` });
                             return `Error creating tool '${args.name}'.`;
                         }
                     }
                 }
                 // Add other base tools here if desired (e.g., list_artifacts, get_player_status)
             };
        }

        function formatToolsForLLM() {
            // Use a format that models like Qwen2.5 Coder might understand better for custom tool use
             let toolPrompt = "You are an AI assistant controlling the Abyss. You can interact with the game world using the following tools. To use a tool, respond *only* with a JSON object representing the function call, enclosed in <tool_call> tags.\n";
             toolPrompt += "Format: <tool_call name=\"tool_name\">{ \"param1\": \"value1\", ... }</tool_call>\n\n";
             toolPrompt += "Available Tools:\n";
             for (const name in availableLLMTools) {
                 const tool = availableLLMTools[name];
                 toolPrompt += `- Name: ${name}\n`;
                 toolPrompt += `  Description: ${tool.description}\n`;
                 // Describe parameters clearly for the LLM
                 toolPrompt += `  Parameters (JSON object):\n    ${JSON.stringify(tool.parameters, null, 4).replace(/\n/g, '\n    ')}\n`;
             }
             toolPrompt += "\nOnly respond with a <tool_call> structure if you intend to use a tool. Otherwise, respond with a natural language message.";
             return toolPrompt;
        }

        async function sendAbyssMessage(messages, internalCall = false) {
            if (!llmReady || llmLoading) {
                logMessage("LLM is not ready.", 'error');
                return "LLM not available.";
            }
            if (!internalCall) {
                logMessage("Sending message to Abyss...", 'llm');
                logEvent('llm_request_sent', { historyLength: messages.length, lastMessage: messages[messages.length - 1] });
            }

            const temperature = parseFloat(llmTemperatureSlider.value);
            let responseText = "";

            // Prepare messages, injecting tool definitions before the last user message
             const toolDefinitions = formatToolsForLLM();
             const messagesWithTools = [...messages];
             if (messagesWithTools.length > 0 && messagesWithTools[messagesWithTools.length - 1].role === 'user') {
                 const lastUserMessage = messagesWithTools.pop();
                 // Inject tool info as a specific instruction block using 'user' role for compatibility
                 messagesWithTools.push({ role: 'user', content: `--- AVAILABLE TOOLS ---\n${toolDefinitions}\n--- END TOOLS ---` });
                 messagesWithTools.push(lastUserMessage);
             } else {
                 // If history is empty or doesn't end with user, add tools anyway
                  messagesWithTools.push({ role: 'user', content: `--- AVAILABLE TOOLS ---\n${toolDefinitions}\n--- END TOOLS ---` });
                  if(messages.length > 0) messagesWithTools.push(messages[messages.length - 1]); // Re-add last message if it wasn't user
             }


            // Limit context size (simple truncation for now)
            const MAX_TOKENS_APPROX = 3000; // Very rough estimate
            let currentTokens = 0;
            const processedMessages = [];
            for(let i = messagesWithTools.length - 1; i >= 0; i--) {
                const msg = messagesWithTools[i];
                const tokens = (msg.content.length / 4); // Rough estimate
                if (currentTokens + tokens > MAX_TOKENS_APPROX && processedMessages.length > 0) {
                    logMessage(`Truncating LLM history (approx ${currentTokens} tokens)`, 'llm');
                    break; // Stop adding messages
                }
                processedMessages.unshift(msg);
                currentTokens += tokens;
            }


            try {
                let rawResponseContent = "";
                if (llmType === 'webllm') {
                    const isDeepSeekR1 = llmModelId.toLowerCase().includes('deepseek-r1');
                    const webLlmMessages = processedMessages.map(msg => ({ role: msg.role, content: msg.content }));

                    const response = await llmEngine.chat.completions.create({
                        messages: webLlmMessages,
                        temperature: temperature,
                        stream: false, // Keep false for easier tool parsing
                    });
                    rawResponseContent = response.choices[0]?.message?.content || "";

                    // Handle DeepSeek-R1 <think> tag
                     if (isDeepSeekR1 && rawResponseContent.startsWith("<think>")) {
                         const thinkEndIndex = rawResponseContent.indexOf("</think>");
                         if (thinkEndIndex !== -1) {
                             const thought = rawResponseContent.substring("<think>".length, thinkEndIndex).trim();
                             if (!internalCall) logMessage(`LLM Thought: ${thought}`, 'llm');
                             logEvent('llm_thought', { text: thought });
                             rawResponseContent = rawResponseContent.substring(thinkEndIndex + "</think>".length).trim();
                         } else {
                             rawResponseContent = rawResponseContent.substring("<think>".length).trim(); // Remove tag anyway
                         }
                     }

                } else if (llmType === 'llmjs') {
                    const isDeepSeekR1 = llmModelId.toLowerCase().includes('deepseek-r1');
                    let promptString = "";

                    if (isDeepSeekR1) {
                         processedMessages.forEach(msg => {
                             promptString += msg.role === 'user' ? `<｜User｜>\n${msg.content}` : `<｜Assistant｜>\n${msg.content}`;
                         });
                         promptString += "<｜Assistant｜>\n";
                    } else { // Assume ChatML for Qwen 2.5
                         processedMessages.forEach(msg => {
                             promptString += `<|im_start|>${msg.role}\n${msg.content}<|im_end|>\n`;
                         });
                         promptString += `<|im_start|>assistant\n`;
                    }

                    let accumulatedResponse = "";
                    let resolveResponse;
                    const responsePromise = new Promise(resolve => { resolveResponse = resolve; });

                    llmJsInstance.write_result = (text) => { accumulatedResponse += text; };
                    llmJsInstance.run_complete = () => { resolveResponse(accumulatedResponse); };

                    llmJsInstance.run({ prompt: promptString, temperature: temperature, top_k: 40 });
                    rawResponseContent = await responsePromise;

                     // Handle DeepSeek-R1 <think> tag for llm.js output
                     if (isDeepSeekR1 && rawResponseContent.startsWith("<think>")) {
                         const thinkEndIndex = rawResponseContent.indexOf("</think>");
                         if (thinkEndIndex !== -1) {
                             const thought = rawResponseContent.substring("<think>".length, thinkEndIndex).trim();
                             if (!internalCall) logMessage(`LLM Thought: ${thought}`, 'llm');
                              logEvent('llm_thought', { text: thought });
                             rawResponseContent = rawResponseContent.substring(thinkEndIndex + "</think>".length).trim();
                         } else {
                             rawResponseContent = rawResponseContent.substring("<think>".length).trim();
                         }
                     }
                } else {
                    throw new Error("LLM type not implemented for sending messages.");
                }

                if (!internalCall) logMessage(`Abyss Raw Response: ${rawResponseContent}`, 'llm');
                 logEvent('llm_response_received', { rawContent: rawResponseContent });

                // --- Custom Tool Call Parsing (Updated Regex) ---
                // Look for <tool_call name="tool_name">{ ...JSON... }</tool_call>
                const toolCallRegex = /<tool_call name="([^"]+)">([\s\S]*?)<\/tool_call>/;
                const match = rawResponseContent.match(toolCallRegex);

                if (match) {
                    const toolName = match[1];
                    const toolArgsJson = match[2].trim();
                    logMessage(`Detected tool call for: ${toolName}`, 'llm');

                    if (availableLLMTools[toolName]) {
                        try {
                            const toolArgs = JSON.parse(toolArgsJson);
                            logMessage(`Calling tool ${toolName} with args: ${JSON.stringify(toolArgs)}`, 'llm');
                            logEvent('llm_tool_execution_started', { toolName: toolName, args: toolArgs });

                            // Execute the tool function (can be async)
                            const toolResult = await availableLLMTools[toolName].function(toolArgs);
                            const resultString = (typeof toolResult === 'object' ? JSON.stringify(toolResult) : String(toolResult)) || "Tool executed."; // Ensure result is string
                            logMessage(`Tool ${toolName} result: ${resultString}`, 'llm');
                            logEvent('llm_tool_execution_finished', { toolName: toolName, result: resultString });


                            // Add the tool call and result to the history and resend
                            const messagesWithToolResult = [
                                ...messages, // Use original messages before tool injection/truncation
                                { role: 'assistant', content: rawResponseContent }, // LLM's response containing the tool call
                                // Use a 'user' role for tool results for compatibility, clearly marking it
                                { role: 'user', content: `--- TOOL RESULT (${toolName}) ---\n${resultString}\n--- END TOOL RESULT ---` }
                            ];

                             // Resend to LLM with the tool result included
                             // Prevent infinite loops: Add a depth counter? For now, just proceed.
                             return await sendAbyssMessage(messagesWithToolResult, internalCall);

                        } catch (e) {
                            logMessage(`Error parsing tool arguments or executing tool ${toolName}: ${e}`, 'error');
                            logEvent('llm_tool_failed', { toolName: toolName, argsJson: toolArgsJson, error: `Execution/Parse Error: ${e.message}` });
                            // Respond with error message instead of calling tool again
                            responseText = `Error processing tool call for ${toolName}: ${e.message}`;
                        }
                    } else {
                        logMessage(`LLM tried to call unknown tool: ${toolName}`, 'error');
                        logEvent('llm_tool_failed', { toolName: toolName, argsJson: toolArgsJson, error: 'Unknown tool' });
                        // Respond with error message
                        responseText = `Error: Unknown tool '${toolName}'.`;
                    }
                } else {
                    // No tool call detected, this is the final natural language response
                    responseText = rawResponseContent;
                }

            } catch (error) {
                logMessage(`Error during LLM communication: ${error}`, 'error');
                console.error("LLM Error:", error);
                 logEvent('llm_error', { context: internalCall ? 'internal' : 'user_chat', message: error.message, stack: error.stack });
                 responseText = `Abyss communication error: ${error.message}`;
                 // Simple retry could be added here if needed
            }

            return responseText; // Return the final response (either text or error message)
        }

        async function handleChatSubmit() {
            const message = chatInput.value.trim();
            if (!message || !llmReady || llmLoading) return;

            logMessage(`Player: ${message}`, 'user');
            chatInput.value = '';
            chatInput.disabled = true; // Disable input while processing
            sendChatButton.disabled = true;

            // Add user message to history
            chatHistory.push({ role: 'user', content: message });
            if (chatHistory.length > MAX_CHAT_HISTORY) {
                chatHistory.splice(0, chatHistory.length - MAX_CHAT_HISTORY); // More robust truncation
            }

            // Special handling for tool_creation_tool usage via chat command
            let isToolCreationCommand = false;
            if (player && player.hasAbility('tool_creation_tool')) {
                 const createToolMatch = message.match(/^\/create_tool\s+name="([^"]+)"\s+description="([^"]+)"/i);
                 if (createToolMatch) {
                     isToolCreationCommand = true;
                     const toolName = createToolMatch[1];
                     const toolDescription = createToolMatch[2];
                     logMessage(`Player using tool_creation_tool artifact to create: ${toolName}`, 'llm');
                     logEvent('player_command', { command: '/create_tool', name: toolName, description: toolDescription });

                     // Manually call the base tool_creation_tool function
                     const creationResult = await availableLLMTools.tool_creation_tool.function({ name: toolName, description: toolDescription });
                     logMessage(`Abyss (Tool Creation): ${creationResult}`, 'llm');
                     chatHistory.push({ role: 'assistant', content: creationResult }); // Add result to history
                 }
            }

            if (!isToolCreationCommand) {
                 // Send history to LLM and get response
                 const response = await sendAbyssMessage(chatHistory);
                 logMessage(`Abyss: ${response}`, 'llm');

                 // Add assistant response to history (if it's not empty/error?)
                 if (response) {
                     chatHistory.push({ role: 'assistant', content: response });
                     if (chatHistory.length > MAX_CHAT_HISTORY) {
                         chatHistory.splice(0, chatHistory.length - MAX_CHAT_HISTORY);
                     }
                 }
            }

            chatInput.disabled = false; // Re-enable input
            sendChatButton.disabled = false;
            chatInput.focus(); // Focus back on input
        }

        // --- UI Updates ---
        function updatePlayerUI() {
            if (!player) return;
            // Update button states based on available artifacts
            const canMelee = player.hasAbility('attack_melee');
            const canRange = player.hasAbility('attack_range');
            attackMeleeButton.disabled = !canMelee;
            attackRangeButton.disabled = !canRange;
            // Interact button always enabled for now
            interactButton.disabled = false;
        }

        // --- Game Setup ---
        function setupInitialWorld() {
            logMessage("Setting up initial world state (Non-LLM)...", 'system');

            // Player
            player = new Entity('player_0', { x: 0, y: 1, z: ARENA_RADIUS * 0.8 }, true);
            // Use window scope for access in tool functions if needed
            window.player = player;
            window.entities = entities;
            window.artifacts = artifacts;
            window.createArtifact = createArtifact;
            window.logMessage = logMessage;
            window.logEvent = logEvent;
            window.THREE = THREE;
            window.RAPIER = RAPIER;


            const startMove = createArtifact('move', { x: player.mesh.position.x + 1, y: 0.5, z: player.mesh.position.z });
            const startSee = createArtifact('see', { x: player.mesh.position.x - 1, y: 0.5, z: player.mesh.position.z });
            // Ensure pickup happens correctly
            setTimeout(() => { // Delay slightly to ensure physics body is ready?
                 player?.addArtifact(startMove);
                 player?.addArtifact(startSee);
                 updatePlayerUI(); // Update UI after adding artifacts
            }, 100); // Short delay


            // Goal Artifact
            createArtifact('tool_creation_tool', { x: 0, y: 0.5, z: -ARENA_RADIUS * 0.8 }); // Place near center edge

            // Other Artifacts (Scattered)
            for (let i = 0; i < 20; i++) {
                createArtifact();
            }

            // Enemies (Different levels/circles)
            const numEnemies = 10;
            for (let i = 0; i < numEnemies; i++) {
                const level = Math.floor(i / (numEnemies / 3)); // 0, 1, 2
                const radius = ARENA_RADIUS * (0.6 - level * 0.25); // Closer to center for higher levels
                const angle = Math.random() * Math.PI * 2;
                const pos = { x: Math.cos(angle) * radius, y: 1, z: Math.sin(angle) * radius };
                const enemy = new Entity(`creature_${entityIdCounter++}`, pos);

                // Give enemies basic artifacts
                 setTimeout(() => { // Delay slightly
                     enemy?.addArtifact(createArtifact('move', { ...pos, y: 0.5, x: pos.x + 0.5 }));
                     enemy?.addArtifact(createArtifact('see', { ...pos, y: 0.5, x: pos.x - 0.5 }));
                     if (level >= 0) { // All enemies get melee
                          enemy?.addArtifact(createArtifact('attack_melee', { ...pos, y: 0.5, z: pos.z + 0.5 }));
                     }
                      if (level >= 1 && Math.random() < 0.5) { // Level 1+ have chance for range
                          enemy?.addArtifact(createArtifact('attack_range', { ...pos, y: 0.5, z: pos.z - 0.5 }));
                      }
                 }, 150 + i * 10); // Stagger enemy artifact addition slightly
            }

            logMessage("Initial world setup complete.", 'system');
        }

        // --- Main Initialization ---
        async function init() {
            logMessage("Initializing Abyss Arena...", 'system');
            loadingOverlay.textContent = "Initializing Graphics...";
            // Basic Three.js Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial camera position might be updated later based on player spawn
            camera.position.set(0, 15, ARENA_RADIUS * 1.1);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606070, 1); // Slightly brighter ambient
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(8, 12, 10); // Adjust angle
            directionalLight.castShadow = true;
            // Configure shadow map
             directionalLight.shadow.mapSize.width = 1024;
             directionalLight.shadow.mapSize.height = 1024;
             directionalLight.shadow.camera.near = 0.5;
             directionalLight.shadow.camera.far = 50;
             directionalLight.shadow.camera.left = -ARENA_RADIUS * 1.2;
             directionalLight.shadow.camera.right = ARENA_RADIUS * 1.2;
             directionalLight.shadow.camera.top = ARENA_RADIUS * 1.2;
             directionalLight.shadow.camera.bottom = -ARENA_RADIUS * 1.2;

            scene.add(directionalLight);
            // Add a light helper (optional, for debugging)
            // const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);
            // scene.add(lightHelper);
             // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
             // scene.add(shadowHelper);


            // Physics
            loadingOverlay.textContent = "Initializing Physics...";
            await initPhysics();

            // Arena
            loadingOverlay.textContent = "Building Arena...";
            setupArena();

            // Controls
            loadingOverlay.textContent = "Setting up Controls...";
            initControls();

             // LLM Setup UI Listeners
             llmEngineSelect.addEventListener('change', updateLLMControls);
             loadLlmButton.addEventListener('click', loadLLM);
             llmTemperatureSlider.addEventListener('input', () => {
                 temperatureValueSpan.textContent = llmTemperatureSlider.value;
             });
             chatInput.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter' && !e.shiftKey) {
                     e.preventDefault();
                     handleChatSubmit();
                 }
             });
             sendChatButton.addEventListener('click', handleChatSubmit);
             updateLLMControls(); // Initial UI state

             // Initial Tools
             availableLLMTools = { ...getBaseLLMTools() };


            // Pre-create world content for instant playability
            loadingOverlay.textContent = "Populating Abyss...";
            setupInitialWorld(); // Creates player, enemies, artifacts

             // Demo Mode Button Listener
             toggleDemoButton.addEventListener('click', () => {
                 demoModeActive = !demoModeActive;
                 if (demoModeActive) {
                     toggleDemoButton.textContent = 'Disable Demo Mode';
                     demoStatusDiv.textContent = 'Demo: ON';
                     logMessage("Demo Mode Enabled.", 'system');
                     demoState = 'IDLE'; // Reset state
                     demoStateTimer = DEMO_STATE_TIMEOUT; // Force immediate check
                     demoTargetArtifact = null;
                     demoTargetEntity = null;
                 } else {
                     toggleDemoButton.textContent = 'Enable Demo Mode';
                     demoStatusDiv.textContent = 'Demo: OFF';
                     logMessage("Demo Mode Disabled.", 'system');
                     // Reset input state when disabling demo
                     Object.keys(inputState).forEach(key => {
                         if (typeof inputState[key] === 'number') inputState[key] = 0;
                         if (typeof inputState[key] === 'boolean') inputState[key] = false;
                         if (typeof inputState[key] === 'object' && inputState[key] !== null) {
                             inputState[key].x = 0; inputState[key].y = 0;
                         }
                     });
                 }
             });

             // Recording Button Listeners
             startRecordingButton.addEventListener('click', startRecording);
             stopRecordingButton.addEventListener('click', stopRecording);


            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start the game loop
            loadingOverlay.style.display = 'none'; // Hide loading screen
            logMessage("Initialization Complete. Starting Game Loop.", 'system');
            animate();
        }

        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); // Get delta time, clamp to prevent large jumps

            // Increment frame counter if recording
            if (isRecording) {
                frameCounter++;
            }

            // 1. Process Input (User or Demo) -> Modifies inputState
            if (demoModeActive) {
                processDemoInput(deltaTime);
            } else {
                processInput(deltaTime);
            }

            // 2. Apply Input State to Physics -> Reads inputState, applies forces/torques, triggers actions
            let interactionTriggered = false; // Track momentary actions
            let meleeTriggered = false;
            let rangeTriggered = false;

            if (player && player.rigidBody && physicsWorld.getRigidBody(player.rigidBody.handle)) {
                let moveImpulse = { x: 0, y: 0, z: 0 };
                let rotationTorque = { y: 0 };
                const moveSpeed = 40.0; // Impulse multiplier per second
                const rotateSpeed = 2.0; // Torque multiplier per second

                // Combine movement inputs (allow diagonal)
                let moveZ = inputState.moveBackward - inputState.moveForward;
                let moveX = inputState.moveRight - inputState.moveLeft;
                // Combine rotation inputs
                rotationTorque.y = (inputState.rotateLeft - inputState.rotateRight) * rotateSpeed;

                // Apply Movement based on 'move' artifact
                if (player.hasAbility('move') && (moveX !== 0 || moveZ !== 0)) {
                    const moveVec = new THREE.Vector3(moveX, 0, moveZ);
                    moveVec.normalize().multiplyScalar(moveSpeed * deltaTime); // Scale by delta time
                    const worldImpulse = moveVec.applyQuaternion(player.mesh.quaternion);
                    player.rigidBody.applyImpulse(worldImpulse, true);
                    player.lastMoveTime = Date.now();
                } else if ((moveX !== 0 || moveZ !== 0) && !player.hasAbility('move')) {
                    if (!demoModeActive) logMessage("Cannot move without a 'move' artifact!", 'warning');
                }

                // Apply Rotation
                if (rotationTorque.y !== 0) {
                    player.rigidBody.applyTorqueImpulse({ x: 0, y: rotationTorque.y * deltaTime, z: 0 }, true); // Scale torque by delta time
                    player.lastSeeTime = Date.now();
                }

                 // Check Momentary Actions (Interact, Attack)
                 if (inputState.actionInteract) {
                     player.interact();
                     interactionTriggered = true;
                 }
                 if (inputState.actionMelee) {
                     player.performAttack('attack_melee'); // Cooldown handled inside
                     meleeTriggered = true;
                 }
                 if (inputState.actionRange) {
                     player.performAttack('attack_range'); // Cooldown handled inside
                     rangeTriggered = true;
                 }
            }

            // 3. Step Physics World & Handle Collisions
            if (physicsWorld) {
                physicsWorld.step(eventQueue);
                handleCollisions(); // Process collision events (logs events inside)
            }

            // 4. Update Entities (AI, Artifact Expiration, Sync Graphics)
            entities.forEach(entity => entity.update(deltaTime)); // Logs events inside

            // 5. Update non-entity meshes (like projectiles - visual sync only)
             physicsWorld?.colliders.forEach(collider => {
                 if (collider.userData?.type === 'projectile' && collider.userData.mesh) {
                     const body = collider.parent();
                     // Check if body and mesh still exist
                     if (body && physicsWorld.getRigidBody(body.handle) && collider.userData.mesh.parent) {
                         collider.userData.mesh.position.copy(body.translation());
                         collider.userData.mesh.quaternion.copy(body.rotation());
                     } else if (collider.userData.mesh.parent) {
                         // Body gone but mesh remains? Remove mesh.
                         scene.remove(collider.userData.mesh);
                         logEvent('projectile_mesh_cleanup', { projectileId: collider.userData.id });
                     }
                 }
             });

            // 6. Log Frame Data (After updates, captures the state for this frame)
            if (isRecording) {
                logFrameData(deltaTime);
            }

            // 7. Reset Momentary Action Flags from inputState
            // Do this *after* logging the frame data which includes the applied input state
            if(interactionTriggered) inputState.actionInteract = false;
            if(meleeTriggered) inputState.actionMelee = false;
            if(rangeTriggered) inputState.actionRange = false;
            // Note: Continuous flags (moveForward etc.) are reset by input devices/demo logic each frame.


            // 8. Update Camera
            if (player && player.mesh) {
                const offset = new THREE.Vector3(0, 4, 6); // Adjusted offset
                // Apply player rotation to offset, then add to player position
                const desiredPosition = player.mesh.position.clone().add(offset.clone().applyQuaternion(player.mesh.quaternion));
                // Smoothly interpolate camera position
                camera.position.lerp(desiredPosition, 0.08); // Adjust lerp factor for smoothness

                // Look at a point slightly above the player's base
                const lookAtTarget = player.mesh.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                // Smoothly interpolate lookAt target? Or just look directly? Direct look is usually fine.
                camera.lookAt(lookAtTarget);
            }


            // 9. Enforce Arena Boundaries (Physics should handle this, but as a fallback)
             entities.forEach(entity => {
                 if (entity.rigidBody && physicsWorld.getRigidBody(entity.rigidBody.handle)) {
                     const pos = entity.rigidBody.translation();
                     const distSq = pos.x * pos.x + pos.z * pos.z;
                     const maxDistSq = (ARENA_RADIUS - 0.5) * (ARENA_RADIUS - 0.5); // Keep slightly inside radius

                     if (distSq > maxDistSq) {
                         const dist = Math.sqrt(distSq);
                         const correctionFactor = (ARENA_RADIUS - 0.5) / dist;
                         const correctedPos = { x: pos.x * correctionFactor, y: pos.y, z: pos.z * correctionFactor };
                         entity.rigidBody.setTranslation(correctedPos, true);
                         // Optional: Zero out velocity pointing outwards?
                         const vel = entity.rigidBody.linvel();
                         const radialDir = {x: correctedPos.x / (dist || 1), z: correctedPos.z / (dist || 1)};
                         const outwardSpeed = vel.x * radialDir.x + vel.z * radialDir.z;
                         if (outwardSpeed > 0) {
                             entity.rigidBody.setLinvel({x: vel.x - radialDir.x * outwardSpeed, y: vel.y, z: vel.z - radialDir.z * outwardSpeed}, true);
                         }
                         logEvent('boundary_enforced', { entityId: entity.id, position: [pos.x, pos.y, pos.z] });
                     }
                     // Keep entities above ground
                     if (pos.y < 0.1) {
                        entity.rigidBody.setTranslation({x: pos.x, y: 0.1, z: pos.z}, true);
                        entity.rigidBody.setLinvel({x:0, y:0, z:0}, true); // Stop downward velocity
                        logEvent('ground_enforced', { entityId: entity.id, position: [pos.x, pos.y, pos.z] });
                     }
                 }
             });


            // 10. Render Scene
            renderer.render(scene, camera);
        }

        // --- Start ---
        init().catch(err => {
            console.error("Initialization failed:", err);
            logMessage(`Critical Error during Initialization: ${err}`, 'error');
            loadingOverlay.textContent = `Error: ${err.message}. Please refresh.`;
            loadingOverlay.style.display = 'flex'; // Ensure overlay is visible on error
        });

    </script>
</body>
</html>
